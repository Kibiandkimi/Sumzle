<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumzle</title>
    <script src="https://cdn.staticfile.net/Chart.js/3.9.1/chart.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-border-light: #f1f3f5;
            --color-divider: #e9ecef;
            
            --color-correct: #28a745; 
            --color-present: #ffc107; 
            --color-absent: #6c757d;  
            --color-key-feedback-text: #ffffff;

            --color-easy: #17a2b8; 
            --color-medium: #fd7e14; 
            --color-hard: #dc3545;

            --fluent-blue: #007bff;
            --fluent-blue-hover: #0069d9;
            --fluent-blue-active: #0056b3;

            --tile-border-radius: 6px;
            --key-border-radius: 6px; 
            --modal-border-radius: 8px; 
            --button-border-radius: 5px;

            --shadow-xs: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-s: 0 2px 4px rgba(0,0,0,0.07);
            --shadow-m: 0 4px 8px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.06);
            --shadow-l: 0 8px 16px rgba(0,0,0,0.1), 0 0 2px rgba(0,0,0,0.07);
            --shadow-xl: 0 12px 24px rgba(0,0,0,0.12), 0 0 3px rgba(0,0,0,0.08);
        }
        body {
            font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--color-background); color: var(--color-text);
            display: flex; flex-direction: column; align-items: center; height: 100vh; touch-action: manipulation; 
            overflow-x: hidden; 
            overflow-y: auto; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        header {
            width: 100%; padding: 10px 0; border-bottom: 1px solid var(--color-divider); text-align: center; font-weight: 600; 
            font-size: 1.6rem; 
            position: relative; display: flex;
            justify-content: center; align-items: center; background-color: var(--color-surface); 
            min-height: 60px; box-sizing: border-box; 
            box-shadow: var(--shadow-s);
        }
        .header-title { 
            position: absolute; 
            left: 50%;
            transform: translateX(-50%);
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            color: var(--color-text);
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        .header-buttons-container { 
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100; 
        }
        .header-buttons {
            display: flex;
            align-items: center; 
            gap: 8px; 
            transition: opacity 0.3s cubic-bezier(0.215, 0.610, 0.355, 1.000), transform 0.3s cubic-bezier(0.215, 0.610, 0.355, 1.000), visibility 0s 0.3s;
        }
        #menuToggleBtn { display: none; } 

        @media (max-width: 450px) { 
            header { min-height: 56px; padding: 6px 0; }
            .header-buttons {
                opacity: 0;
                visibility: hidden;
                transform: translateY(-15px) scaleY(0.9);
                transform-origin: top right;
                position: absolute;
                top: calc(100% + 8px); 
                right: 0;
                flex-direction: column;
                background-color: var(--color-surface);
                border: 1px solid var(--color-border);
                border-radius: var(--modal-border-radius);
                box-shadow: var(--shadow-m);
                padding: 10px;
                z-index: 999; 
            }
            .header-buttons.show-menu { 
                display: flex; 
                opacity: 1;
                visibility: visible;
                transform: translateY(0) scaleY(1);
                transition: opacity 0.3s cubic-bezier(0.215, 0.610, 0.355, 1.000), transform 0.3s cubic-bezier(0.215, 0.610, 0.355, 1.000), visibility 0s 0s;
            } 
            #menuToggleBtn { 
                display: flex; 
                background: none; border: none; font-size: 1.7rem; cursor: pointer; color: var(--color-text-secondary);
                align-items: center; justify-content: center; width: 44px; height: 44px;
                transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.2s ease-out, color 0.2s ease-out;
                border-radius: var(--button-border-radius);
            }
            #menuToggleBtn:hover { background-color: rgba(0,0,0,0.04); color: var(--color-text); }
            #menuToggleBtn.active { transform: rotate(90deg); color: var(--fluent-blue); }
             .icon-btn {
                width: 100%; 
                justify-content: flex-start; 
                padding: 10px 15px; 
                font-size: 1rem;
                height: auto;
            }
            .icon-btn:not(:last-child) { margin-bottom: 5px; }
        }
        .icon-btn {
            background: none; border: none; font-size: 1.6rem; 
            cursor: pointer; color: var(--color-text-secondary); 
            display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; 
            transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), color 0.2s ease-out, background-color 0.2s ease-out;
            border-radius: var(--button-border-radius);
        }
        .icon-btn:hover { color: var(--color-text); background-color: rgba(0,0,0,0.04); }
        .icon-btn:active { transform: scale(0.90); }

        .difficulty-indicator { 
            position: absolute; left: 15px; 
            top: 50%; transform: translateY(-50%); 
            font-size: 0.75rem; 
            padding: 6px 14px; color: white; border-radius: 18px; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: var(--shadow-xs);
        }
        .difficulty-easy { background-color: var(--color-easy); }
        .difficulty-medium { background-color: var(--color-medium); }
        .difficulty-hard { background-color: var(--color-hard); }
        
        .game-container {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            flex-grow: 1; width: 100%; 
            padding: 15px; box-sizing: border-box; 
            overflow-x: hidden; 
        }
        .board-wrapper { 
            width: 100%;
            max-width: 100vw; 
            overflow-x: auto;
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch; 
            padding-bottom: 5px; 
        }
        .board { 
            display: grid; gap: 6px; 
            min-width: 100%; 
            width: max-content; 
            padding: 2px; 
        }
        .row { display: grid; gap: 6px; min-width: max-content; }
        .tile {
            aspect-ratio: 1; border: 2px solid var(--color-border-light); display: flex; justify-content: center; align-items: center;
            font-size: 1.8rem; 
            font-weight: 600; border-radius: var(--tile-border-radius);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; 
            box-sizing: border-box; overflow: hidden; text-overflow: clip; color: var(--color-text); background-color: var(--color-surface); 
            min-height: 48px; height: auto; min-width: 48px; 
            box-shadow: var(--shadow-xs);
            position: relative; 
            z-index: 1;
        }
        @media (max-width: 500px) { 
            .tile { min-height: 42px; font-size: 1.6rem; min-width: 42px; border-width: 1px;}
        }
        .tile.filled { border-color: #9e9e9e; box-shadow: var(--shadow-s); } 
        .tile.pop { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { 0% { transform: scale(0.75); opacity: 0.4; } 100% { transform: scale(1); opacity: 1; } }
        
        .tile.flip-reveal { animation: flip-reveal 0.7s cubic-bezier(0.45, 0.05, 0.55, 0.95) forwards; }
        @keyframes flip-reveal { 
            0% { transform: rotateX(0deg); } 
            50% { transform: rotateX(90deg); background-color: var(--color-border-light); } 
            100% { transform: rotateX(0deg); } 
        }
        
        .tile.win-dance { animation: dance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) both; }
        @keyframes dance {
            0%, 100% { transform: translateY(0) scale(1); }
            20% { transform: translateY(-12px) scale(1.12) rotate(-4deg); }
            40% { transform: translateY(6px) scale(0.93) rotate(4deg); }
            60% { transform: translateY(-7px) scale(1.06) rotate(-2.5deg); }
            80% { transform: translateY(3px) scale(0.97) rotate(1.5deg); }
        }
        .correct { background-color: var(--color-correct) !important; color: var(--color-key-feedback-text) !important; border-color: var(--color-correct) !important; box-shadow: none !important; }
        .present { background-color: var(--color-present) !important; color: var(--color-key-feedback-text) !important; border-color: var(--color-present) !important; box-shadow: none !important;}
        .absent { background-color: var(--color-absent) !important; color: var(--color-key-feedback-text) !important; border-color: var(--color-absent) !important; box-shadow: none !important;}
        
        #statusIndicatorWrapper {
            width: 100%; display: flex; justify-content: center;
            margin: 12px 0 18px 0; 
            flex-shrink: 0; height: 40px; 
        }
        #statusIndicator {
            padding: 0 22px; 
            background-color: var(--color-surface); color: var(--color-text-secondary);
            border-radius: 20px; 
            font-size: 0.95rem; font-weight: 500;
            text-align: center; line-height: 40px; 
            box-shadow: var(--shadow-m);
            transition: opacity 0.35s cubic-bezier(0.25, 0.1, 0.25, 1), transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1), min-width 0.3s ease-out, padding 0.3s ease-out;
            opacity: 0; transform: translateY(15px) scale(0.9);
            white-space: nowrap;
            max-width: 85%;
            overflow: hidden; text-overflow: ellipsis;
        }
        #statusIndicator.visible { opacity: 1; transform: translateY(0) scale(1); }
        #statusIndicator.timer-active { 
            min-width: 130px; 
            font-variant-numeric: tabular-nums;
            color: var(--fluent-blue);
        }

        .keyboard { display: flex; flex-direction: column; width: 100%; max-width: 520px; gap: 6px; padding-bottom: 10px; }
        .keyboard-row { display: flex; justify-content: center; gap: 5px; width: 100%; }
        .key {
            height: 54px; 
            border-radius: var(--key-border-radius); 
            background-color: #f1f3f5; 
            font-size: 1.15rem; font-weight: 500;
            display: flex; justify-content: center; align-items: center; cursor: pointer; user-select: none; flex: 1;
            transition: background-color 0.15s ease-out, transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.15s ease-out, border-color 0.15s ease-out; 
            box-shadow: var(--shadow-xs); 
            color: var(--color-text); 
            border: 1px solid #ced4da;
            position: relative; 
            z-index: 1;
            overflow: hidden; 
        }
        .key.show-tooltip {
            overflow: visible; 
        }
        .key::before {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            z-index: -1;
            transition: height 0.3s cubic-bezier(0.645, 0.045, 0.355, 1.000);
            border-radius: inherit;
        }

        .key:not(.correct):not(.present):not(.absent):hover {
            background-color: #e9ecef;
        }
        .key:not(.correct):not(.present):not(.absent):active,
        .key.pressed:not(.correct):not(.present):not(.absent) { 
            background-color: #dee2e6; 
            transform: scale(0.95) translateY(1px); 
            box-shadow: none;
        }

        .key.wide { flex: 1.5; font-size: 0.95rem;}
        .key.super-wide { 
            flex: 1.5;
            background-color: var(--fluent-blue); color: white; border-color: var(--fluent-blue-hover);
            font-weight: 600;
        }
        .key.super-wide:not(.correct):not(.present):not(.absent):hover { 
            background-color: var(--fluent-blue-hover); 
        }
        .key.super-wide:not(.correct):not(.present):not(.absent):active { 
            background-color: var(--fluent-blue-active); 
        }
        
        .key.correct, .key.present, .key.absent {
            background-color: transparent !important;
            color: var(--color-key-feedback-text) !important;
            font-weight: 600;
        }
        .key.correct { 
            border-color: var(--color-correct) !important; 
            animation: keyGreenPulse 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        }
        .key.present { border-color: var(--color-present) !important; }
        .key.absent { border-color: var(--color-absent) !important; opacity: 0.9; }

        .key.correct::before { background-color: var(--color-correct); height: 100%; }
        .key.present::before { background-color: var(--color-present); height: 100%; }
        .key.absent::before { background-color: var(--color-absent); height: 100%; }

        @keyframes keyGreenPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08) translateY(-1px); }
        }
        .key.disabled-permanently {
            opacity: 0.45 !important; pointer-events: none !important;
            background-color: #ced4da !important; color: #adb5bd !important;
            border-color: #adb5bd !important;
        }
        .key.disabled-permanently::before { display: none; }
        .key.disabled-view-mode { opacity: 0.55 !important; pointer-events: none !important; }


        .key-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(6px) scale(0.9);
            background-color: var(--color-text);
            color: var(--color-surface);
            padding: 7px 12px;
            border-radius: var(--button-border-radius);
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out, visibility 0s 0.2s;
            box-shadow: var(--shadow-m);
            pointer-events: none;
        }
        .key.operator-key:hover .key-tooltip,
        .key.operator-key.show-tooltip .key-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0) scale(1);
            transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), visibility 0s 0s;
        }


        .message {
            position: fixed; top: 12%; 
            left: 50%; transform: translateX(-50%) translateY(-30px) scale(0.9);
            background-color: rgba(25, 25, 25, 0.95); 
            backdrop-filter: blur(4px);
            color: white; padding: 16px 28px; border-radius: var(--modal-border-radius);
            z-index: 1001; opacity: 0; font-weight: 500; box-shadow: var(--shadow-l);
            visibility: hidden; 
            transition: opacity 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), transform 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), visibility 0s 0.3s;
            width: auto; 
            max-width: 88vw; 
            box-sizing: border-box; 
            text-align: center; 
            white-space: normal; 
            word-break: break-word; 
            font-size: 1.05rem;
        }
        .message.show-message {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            visibility: visible;
            transition: opacity 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275), transform 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275), visibility 0s 0s;
        }
        
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.45); 
            backdrop-filter: blur(6px); 
            z-index: 1000; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s ease-in-out, backdrop-filter 0.3s ease-in-out;
        }
        .modal.show { display: flex; opacity: 1; }
        
        .modal-content {
            background-color: var(--color-surface); padding: 30px; 
            border-radius: var(--modal-border-radius); max-width: 90%; width: 520px;
            text-align: center; max-height: 90vh; overflow-y: auto; box-shadow: var(--shadow-xl);
            opacity: 0;
            transform: translateY(30px) scale(0.95); 
            transition: opacity 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275), transform 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        }
        .modal.show .modal-content {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .modal h2 { margin-top: 0; margin-bottom: 22px; color: var(--color-text); font-size: 1.8rem; font-weight: 600;}
        .modal p { color: var(--color-text-secondary); font-size: 1.05rem; line-height: 1.65; margin-bottom: 28px;}
        
        .modal button {
            color: white; border: none; padding: 13px 26px; border-radius: var(--button-border-radius); 
            font-weight: 500; font-size: 1rem; cursor: pointer; margin-top: 15px; 
            transition: background-color 0.2s ease-out, transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s ease-out;
            min-width: 125px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .modal button.primary-btn { background-color: var(--fluent-blue); }
        .modal button.primary-btn:hover { background-color: var(--fluent-blue-hover); box-shadow: var(--shadow-s); }
        .modal button.primary-btn:active { background-color: var(--fluent-blue-active); transform: scale(0.96); }

        .modal button.secondary-btn {
            background-color: #e9ecef; color: var(--color-text); border: 1px solid var(--color-border);
        }
        .modal button.secondary-btn:hover { background-color: #dee2e6; border-color: #ced4da; box-shadow: var(--shadow-s); }
        .modal button.secondary-btn:active { background-color: #ced4da; transform: scale(0.96); }

        .modal button.danger-btn { background-color: var(--color-hard) !important; }
        .modal button.danger-btn:hover { background-color: #c82333 !important; box-shadow: var(--shadow-s); }
        .modal button.danger-btn:active { background-color: #bd2130 !important; transform: scale(0.96);}
        
        #gameOverTitle { font-size: 2.2rem; font-weight: 700; }
        #gameOverMessage { font-size: 1.15rem; margin-bottom: 28px; color: var(--color-text-secondary); }
        .stats-container { display: flex; justify-content: space-around; width: 100%; margin: 35px 0; }
        .stat { display: flex; flex-direction: column; align-items: center; }
        .stat-number { font-size: 2.4rem; font-weight: 700; color: var(--color-text); }
        .stat-label { font-size: 0.85rem; text-transform: uppercase; color: var(--color-text-secondary); letter-spacing: 0.8px; margin-top: 5px; }
        
        .difficulty-selector { display: flex; justify-content: space-between; margin: 28px 0; width: 100%; gap: 12px; }
        .difficulty-btn {
            padding: 14px 10px; border-radius: var(--button-border-radius); cursor: pointer; flex: 1; text-align: center;
            font-weight: 600; color: white; font-size: 0.95rem;
            border: 2px solid transparent; 
            opacity: 0.9; 
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.25s ease-out, opacity 0.25s ease-out, border-color 0.25s ease-out, background-color 0.25s ease-out;
            box-shadow: var(--shadow-xs);
            line-height: 1.4;
        }
        .difficulty-btn:not(.selected):hover {
            opacity: 1;
            transform: translateY(-3px);
            box-shadow: var(--shadow-m);
        }
        .difficulty-btn.selected {
            opacity: 1;
            transform: scale(1.03) translateY(-4px); 
            border-width: 2px; 
            font-weight: 700;
        }
        .difficulty-btn.easy { background-color: var(--color-easy); }
        .difficulty-btn.medium { background-color: var(--color-medium); }
        .difficulty-btn.hard { background-color: var(--color-hard); }
        .difficulty-btn.easy.selected { border-color: #138496; box-shadow: 0 4px 12px rgba(23, 162, 184, 0.4); }
        .difficulty-btn.medium.selected { border-color: #e06200; box-shadow: 0 4px 12px rgba(253, 126, 20, 0.4); }
        .difficulty-btn.hard.selected { border-color: #bd2130; box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4); }

        #exportImageBtn { background-color: var(--color-present); color: var(--color-text) !important; margin-left: 10px;}
        #exportImageBtn:hover { background-color: #e0a800 !important; }
        #shareLevelBtn { margin-left: 10px;} 

        .flying-char-effect {
            position: fixed; z-index: 9999; pointer-events: none;
            transition: transform 0.35s cubic-bezier(0.34, 0, 0.66, 1.5), opacity 0.45s ease-out, width 0.35s ease-out, height 0.35s ease-out;
            opacity: 1; display: flex; align-items: center; justify-content: center;
            box-shadow: var(--shadow-m); 
        }
         #confettiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            overflow: hidden;
            z-index: 10000; 
        }
        .confetti-piece {
            position: absolute; 
            pointer-events: none;
            transition-property: transform, top, opacity;
            transition-timing-function: cubic-bezier(0.1, 0.5, 0.3, 1), cubic-bezier(0.1, 0.25, 0.3, 1), ease-in;
            will-change: transform, top, opacity;
        }
        
        .invalid-shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translateX(-1.5px); } 20%, 80% { transform: translateX(3px); }
            30%, 50%, 70% { transform: translateX(-5px); } 40%, 60% { transform: translateX(5px); }
        }
        textarea#levelCodeInput {
            width: 95%; margin-bottom: 18px; padding: 14px; border-radius: var(--button-border-radius); 
            border: 1px solid var(--color-border); font-size: 1rem;
            background-color: var(--color-background); color: var(--color-text);
            line-height: 1.5;
        }
        textarea#levelCodeInput:focus {
            border-color: var(--fluent-blue); box-shadow: 0 0 0 3px rgba(0,123,255,0.25); outline: none;
        }
        .tile.tile-new-game-appear {
            opacity: 0;
            transform: scale(0.5) translateY(15px);
            animation: tileNewGameAppearAnimation 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes tileNewGameAppearAnimation {
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        .tile.tile-cleared-animation {
            animation: tileClearPop 0.35s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
        }
        @keyframes tileClearPop {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            30% { transform: scale(1.1) rotate(-4deg); opacity: 0.8; }
            100% { transform: scale(0.25) rotate(18deg); opacity: 0; }
        }
        #historyListContainer {
            max-height: 60vh; 
            overflow-y: auto;
            margin-bottom: 22px;
            padding-right: 12px; 
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) var(--color-background);
        }
        #historyListContainer::-webkit-scrollbar { width: 8px; }
        #historyListContainer::-webkit-scrollbar-track { background: var(--color-background); border-radius: 4px;}
        #historyListContainer::-webkit-scrollbar-thumb { background-color: var(--color-border); border-radius: 4px; border: 2px solid var(--color-background); }

        .history-item {
            background-color: var(--color-background);
            border: 1px solid var(--color-border-light);
            border-radius: var(--button-border-radius);
            padding: 18px;
            margin-bottom: 14px;
            text-align: left;
            box-shadow: var(--shadow-s);
            transition: box-shadow 0.25s ease-out, transform 0.25s ease-out;
        }
        .history-item:hover {
            box-shadow: var(--shadow-m);
            transform: translateY(-2px) scale(1.005);
        }
        .history-item-preview {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .history-equation {
            font-weight: 600;
            font-size: 1.15rem;
            color: var(--color-text);
            flex-grow: 1;
            margin-right: 12px;
            word-break: break-all;
        }
        .history-status {
            font-size: 0.85rem;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: var(--button-border-radius);
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .history-status.won { background-color: var(--color-correct); }
        .history-status.lost, .history-status.surrendered { background-color: var(--color-hard); }

        .history-item-details {
            font-size: 0.9rem;
            color: var(--color-text-secondary);
            margin-bottom: 14px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px 12px; 
        }
        .history-item-details span {
             white-space: nowrap;
        }

        .history-item-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .history-item-actions button {
            padding: 9px 14px;
            font-size: 0.9rem;
            min-width: auto; 
            margin-top: 0; 
        }
        #noHistoryMessage {
            color: var(--color-text-secondary);
            padding: 25px;
            font-size: 1.05rem;
        }
    </style>
</head>
<body>
    <header>
        <div id="difficultyDisplay" class="difficulty-indicator difficulty-medium">中等</div>
        <div class="header-title">SUMZLE</div>
        <div class="header-buttons-container">
            <button id="menuToggleBtn">☰</button>
            <div class="header-buttons" id="headerButtonsGroup">
                <button class="icon-btn" id="loadLevelBtn" title="载入关卡">🔗</button>
                <button class="icon-btn" id="historyBtn" title="游戏历史">📜</button>
                <button class="icon-btn" id="statsBtn" title="统计">📊</button>
                <button class="icon-btn" id="settingsBtn" title="设置">⚙️</button>
                <button class="icon-btn" id="restartBtn" title="重新开始/投降">🔄</button>
            </div>
        </div>
    </header>
    <div id="confettiOverlay"></div>
    <div class="game-container" id="gameContainer">
        <div class="board-wrapper">
            <div class="board" id="board"></div>
        </div>
        <div id="statusIndicatorWrapper">
             <div id="statusIndicator" class="status-indicator">准备开始</div>
        </div>
        <div class="keyboard" id="keyboard"></div>
    </div>

    <div class="message" id="message"></div>
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle"></h2><p id="gameOverMessage"></p>
            <div class="stats-container">
                <div class="stat"><div class="stat-number" id="gamesPlayed">0</div><div class="stat-label">已玩</div></div>
                <div class="stat"><div class="stat-number" id="gamesWon">0</div><div class="stat-label">获胜</div></div>
                <div class="stat"><div class="stat-number" id="currentStreak">0</div><div class="stat-label">连胜</div></div>
            </div>
            <button id="newGameBtn" class="primary-btn">开始新游戏</button>
            <button id="exportImageBtn" class="secondary-btn" style="display:none;">导出图片</button>
            <button id="shareLevelBtn" class="secondary-btn">分享关卡</button>
        </div>
    </div>
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>设置</h2><h3>难度选择</h3>
            <div class="difficulty-selector">
                <div class="difficulty-btn easy" data-difficulty="easy">简单<br>(8次)</div>
                <div class="difficulty-btn medium selected" data-difficulty="medium">中等<br>(6次)</div>
                <div class="difficulty-btn hard" data-difficulty="hard">困难<br>(4次)</div>
            </div>
            <button id="closeSettingsBtn" class="primary-btn">确定</button>
        </div>
    </div>
    <div class="modal" id="statsModal">
        <div class="modal-content">
            <h2>游戏统计</h2>
            <div style="width: 100%; max-width: 450px; margin: 20px auto;"><canvas id="statsChart"></canvas></div>
            <button id="clearStatsBtn" class="danger-btn">清空统计数据</button>
            <button id="closeStatsBtn" class="secondary-btn" style="margin-top: 10px;">关闭</button>
        </div>
    </div>
    <div class="modal" id="loadLevelModal">
        <div class="modal-content">
            <h2>载入分享关卡</h2>
            <textarea id="levelCodeInput" placeholder="在此处粘贴关卡代码..." rows="3"></textarea>
            <button id="submitLoadLevelBtn" class="primary-btn">载入</button>
            <button id="closeLoadLevelModalBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="surrenderModal">
        <div class="modal-content">
            <h2>放弃挑战？</h2>
            <p>确定要放弃当前的游戏吗？这将会被记录为一次失败。</p>
            <button id="confirmSurrenderBtn" class="danger-btn">确认放弃</button>
            <button id="cancelSurrenderBtn" class="secondary-btn" style="margin-left: 10px;">继续挑战</button>
        </div>
    </div>
    <div class="modal" id="confirmClearStatsModal">
        <div class="modal-content">
            <h2>确认操作</h2>
            <p>确定要清空所有统计数据吗？此操作无法撤销。</p>
            <button id="executeClearStatsBtn" class="danger-btn">确认清空</button>
            <button id="cancelClearStatsBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
     <div class="modal" id="historyModal">
        <div class="modal-content">
            <h2>游戏历史</h2>
            <div id="historyListContainer">
            </div>
            <p id="noHistoryMessage" style="display:none;">暂无历史记录。</p>
            <button id="clearHistoryBtn" class="danger-btn" style="margin-right:10px; display:none;">清空历史</button>
            <button id="closeHistoryModalBtn" class="secondary-btn">关闭</button>
        </div>
    </div>
     <div class="modal" id="confirmClearHistoryModal">
        <div class="modal-content">
            <h2>确认操作</h2>
            <p>确定要清空所有游戏历史记录吗？此操作无法撤销。</p>
            <button id="executeClearHistoryBtn" class="danger-btn">确认清空</button>
            <button id="cancelClearHistoryBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const difficultySetting = {
        easy: { attempts: 8, name: "简单", class: "difficulty-easy" },
        medium: { attempts: 6, name: "中等", class: "difficulty-medium" },
        hard: { attempts: 4, name: "困难", class: "difficulty-hard" }
    };
    let currentDifficulty = "medium";
    let ROWS = difficultySetting[currentDifficulty].attempts;
    const MAX_EQUATION_LENGTH = 15; 
    const MIN_EQUATION_LENGTH = 3;
    let gameActive = true;
    let currentRow = 0;
    let currentCol = 0;
    let guessedEquation = [];
    let targetEquation = '';
    let COLS = 0;
    let isCustomLevel = false; 
    let stats = {
        total: { gamesPlayed: 0, gamesWon: 0, currentStreak: 0, bestStreak: 0 },
        byDifficulty: { easy: { gamesPlayed: 0, gamesWon: 0 }, medium: { gamesPlayed: 0, gamesWon: 0 }, hard: { gamesPlayed: 0, gamesWon: 0 } }
    };
    const initialStats = JSON.parse(JSON.stringify(stats)); 
    let statsChartInstance = null;

    const XOR_KEY = "SUMZLECRYPTLVL";
    const SHARE_SEPARATOR = "::DIFEQ::";

    let activeTooltipKey = null;
    let activeTooltipTimeout = null;

    const keyTooltips = {
        '+': '加法', '-': '减法', '*': '乘法', '/': '除法', '%': '取模', '^': '乘方',
        '>': '大于', '!': '阶乘', 'A': '排列 (mAn)', '(': '左括号', ')': '右括号',
        '[': '取整数部分 ([n])', ']': '取整结束', '=': '等于'
    };

    const statusIndicator = document.getElementById('statusIndicator');
    let gameStartTime = 0;
    let gameTimerInterval = null;
    let elapsedSeconds = 0;
    let guessedEquationsHistory = [];
    let isViewingHistoryState = false;
    let viewingHistoryItem = null;
    const restartBtn = document.getElementById('restartBtn');

    function displayChar(char) {
        if (char === '*') return '×';
        if (char === '/') return '÷';
        return char;
    }

    function encodeLevel(eq, difficulty) {
        const combined = `${difficulty}${SHARE_SEPARATOR}${eq}`;
        let xored = "";
        for (let i = 0; i < combined.length; i++) {
            xored += String.fromCharCode(combined.charCodeAt(i) ^ XOR_KEY.charCodeAt(i % XOR_KEY.length));
        }
        try { return btoa(xored); } catch(e) { console.error("BTOA failed", e); return null; }
    }

    function decodeLevel(encodedLevel) {
        try {
            let xored = atob(encodedLevel);
            let original = "";
            for (let i = 0; i < xored.length; i++) {
                original += String.fromCharCode(xored.charCodeAt(i) ^ XOR_KEY.charCodeAt(i % XOR_KEY.length));
            }
            const parts = original.split(SHARE_SEPARATOR);
            if (parts.length === 2 && difficultySetting[parts[0]]) {
                return { difficulty: parts[0], equation: parts[1] };
            }
            return null;
        } catch (e) {
            console.error("Failed to decode level:", e);
            return null;
        }
    }

    if (localStorage.getItem('sumzleStats')) {
        const savedStats = JSON.parse(localStorage.getItem('sumzleStats'));
        if (savedStats.byDifficulty) stats = savedStats;
        else {
            stats.total.gamesPlayed = savedStats.gamesPlayed || 0; stats.total.gamesWon = savedStats.gamesWon || 0;
            stats.total.currentStreak = savedStats.currentStreak || 0; stats.total.bestStreak = savedStats.bestStreak || 0;
        }
    }
    if (localStorage.getItem('sumzleDifficulty')) {
        const savedDiff = localStorage.getItem('sumzleDifficulty');
        if (difficultySetting[savedDiff]) {
            currentDifficulty = savedDiff;
        }
        ROWS = difficultySetting[currentDifficulty].attempts;
    }

    const validChars = '0123456789+-*/%^=()![]>A';
    window.factorial = function(n) {
        n = Number(n);
        if (isNaN(n) || n < 0 || n !== Math.floor(n)) throw new Error("Factorial non-neg int.");
        if (n > 10) throw new Error("Factorial max 10.");
        if (n === 0 || n === 1) return 1;
        let result = 1; for (let i = 2; i <= n; i++) result *= i; return result;
    };
    window.permutation = function(m, n) {
        m = Number(m); n = Number(n);
        if (isNaN(m) || isNaN(n) || m < 0 || n < 0 || m !== Math.floor(m) || n !== Math.floor(n)) {
            throw new Error("Permutation args must be non-negative integers.");
        }
        if (n > m) throw new Error("In mAn, n cannot be greater than m.");
        if (n === 0) return 1;
        if (m > 10 || n > 10) throw new Error("Permutation arguments too large (max 10 for m, n).");

        let result = 1;
        for (let i = 0; i < n; i++) {
            result *= (m - i);
        }
        return result;
    };

    function updateDifficultyDisplay() {
        const difficultyElement = document.getElementById('difficultyDisplay');
        difficultyElement.className = 'difficulty-indicator'; 
        difficultyElement.classList.add(difficultySetting[currentDifficulty].class);
        difficultyElement.textContent = difficultySetting[currentDifficulty].name;
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.classList.toggle('selected', btn.dataset.difficulty === currentDifficulty);
        });
    }

    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function generateNumberSegment() { return String(getRandomInt(1, 20)); }
    function generateParenthesizedBinaryOpSegment() {
        const a = getRandomInt(1,10); let b = getRandomInt(1,10);
        const ops = ['+','-','*','^','^','^','^','%']; 
        const op = ops[Math.floor(Math.random()*ops.length)];
        if (op === '^') {
            const typeOfPower = Math.random();
            if (typeOfPower < 0.6) { b = getRandomInt(2,3); return `(${a}^${b})`;}
            else { const baseForSqrt = getRandomInt(2, 5); return `(${baseForSqrt*baseForSqrt}^(1/2))`;}
        }
        if (op === '-' && a < b) return `(${b}${op}${a})`;
        if (op === '%' && b === 0) b = getRandomInt(1,5);
        const needsParentheses = op === '^' || op === '%' || op === '*';
       return needsParentheses ? `(${a}${op}${b})` : `${a}${op}${b}`;
    }
    function generateFactorialSegment() { return `${getRandomInt(1,5)}!`;}
    function generateFloorDivSegment() { return `[${getRandomInt(1,10)}/${getRandomInt(2,5)}]`;}
    function generatePermutationSegment() {
       let m = getRandomInt(2, 7); let n = getRandomInt(1, m); return `${m}A${n}`;
    }
    const segmentGenerators = [generateNumberSegment,generateParenthesizedBinaryOpSegment,generateFactorialSegment,generateFloorDivSegment,generatePermutationSegment];
    function isSimpleSegment(expr) {return /^\d+$|^(\d+)!$|^\d+A\d+$/.test(expr);}
    function isRedundantParentheses(segment) {
        if (segment.startsWith("(") && segment.endsWith(")")) {
            const inner = segment.substring(1, segment.length -1);
            if (isSimpleSegment(inner)) return true; 
            if (inner.startsWith("(") && inner.endsWith(")") && checkBrackets(inner)) {
                 try { const outerVal = safeEval(segment); const innerVal = safeEval(inner);
                    if (Math.abs(outerVal - innerVal) < 0.0001) return true;
                } catch (e) { } } } return false; }
    function generateSingleExpressionSegment() {
        let segment = ""; let attempts = 0;
        do { const generator = segmentGenerators[Math.floor(Math.random() * segmentGenerators.length)];
            segment = generator(); attempts++;
            if (attempts > 20) return String(getRandomInt(1,10)); 
            if (isRedundantParentheses(segment)) segment = segment.substring(1, segment.length -1); 
        } while (segment === "" || isRedundantParentheses(segment)); 
        return segment;
    }
    function generateComplexLHS() {
        let expr = generateSingleExpressionSegment();
        const removeOuterParentheses = (str) => {
        if (str.startsWith("(") && str.endsWith(")") && checkBrackets(str.slice(1, -1))) {
            return str.slice(1, -1);
        }
        return str;
    };
    expr = removeOuterParentheses(expr);
        if (Math.random() < 0.7 && expr.length < MAX_EQUATION_LENGTH - 5) {
            const nextSegment = generateSingleExpressionSegment();
            const ops = ['+','-','*','%']; const op = ops[Math.floor(Math.random()*ops.length)];
            const shouldWrap = (segmentStr, operatorToApply) => {
                if (isSimpleSegment(segmentStr)) return false;
                if ((segmentStr.startsWith('(') && segmentStr.endsWith(')') && checkBrackets(segmentStr.substring(1, segmentStr.length - 1))) ||
                    (segmentStr.startsWith('[') && segmentStr.endsWith(']') && checkBrackets(segmentStr.substring(1, segmentStr.length - 1)))) return false;
                if (operatorToApply === '*' || operatorToApply === '/' || operatorToApply === '%' || operatorToApply === '^') return true;
                return false; };
            const exprNeedsParens = shouldWrap(expr, op); const nextNeedsParens = shouldWrap(nextSegment, op);
            if (Math.random() < 0.5) expr = `${exprNeedsParens ? '('+expr+')' : expr}${op}${nextNeedsParens ? '('+nextSegment+')' : nextSegment}`;
            else expr = `${nextNeedsParens ? '('+nextSegment+')' : nextSegment}${op}${exprNeedsParens ? '('+expr+')' : expr}`;
        }
        try { const val = safeEval(expr); if (!Number.isInteger(val) || expr.includes('.')) return String(getRandomInt(1,30));
        } catch(e) { return String(getRandomInt(1,30)); } return expr;
    }
    function generateFallbackEquation() { const a = getRandomInt(1,9); return `${a}+${a}=${a+a}`; }
    function generateRandomEquation() {
        let equation = ''; let attempts = 0; const maxAttempts = 60;
        while (attempts < maxAttempts) {
            const opChance = Math.random(); let mainOperator;
            if (currentDifficulty === "hard" && !isCustomLevel) mainOperator = '=';
            else { if (opChance < 0.85) mainOperator = '='; else mainOperator = '>'; }
            let expr1_str, expr2_str;
            if (mainOperator === '=') {
                expr1_str = generateComplexLHS();
                try { const val1 = safeEval(expr1_str); if (!Number.isInteger(val1) || expr1_str.includes('.')) { attempts++; continue; } expr2_str = String(val1);
                } catch (e) { attempts++; continue; }
            } else { 
                expr1_str = generateSingleExpressionSegment(); expr2_str = generateSingleExpressionSegment();
                try { let val1 = safeEval(expr1_str); let val2 = safeEval(expr2_str);
                    if (!(val1 > val2)) {
                        if (val2 > val1) { [expr1_str, expr2_str] = [expr2_str, expr1_str]; } 
                        else { expr1_str = String(val1 + getRandomInt(1,3)); if(expr1_str.includes('.')){attempts++; continue;} } }
                } catch (e) { attempts++; continue; } }
            if (expr1_str.includes('.') || expr2_str.includes('.')) { attempts++; continue; }
            equation = `${expr1_str}${mainOperator}${expr2_str}`;
            if (equation.length >= MIN_EQUATION_LENGTH && equation.length <= MAX_EQUATION_LENGTH) {
                if (isValidEquation(equation.split(''), true)) break; }
            attempts++; }
        if (attempts >= maxAttempts || !equation || equation.length > MAX_EQUATION_LENGTH) equation = generateFallbackEquation();
        return equation;
    }

    function formatTime(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function updateStatusIndicatorText(text, isTimer = false) {
        const isCurrentlyVisible = statusIndicator.classList.contains('visible');
        const currentText = statusIndicator.textContent;

        statusIndicator.classList.toggle('timer-active', isTimer);
        if (isTimer && !gameTimerInterval && gameActive && gameStartTime > 0) {
            gameTimerInterval = setInterval(updateGameTimerDisplay, 1000);
        } else if (!isTimer && gameTimerInterval) {
            clearInterval(gameTimerInterval);
            gameTimerInterval = null;
        }

        if (isTimer) {
            if (isCurrentlyVisible) {
                statusIndicator.textContent = text;
            } else { 
                statusIndicator.textContent = text;
                statusIndicator.classList.add('visible');
            }
        } else {
            if (isCurrentlyVisible && currentText !== text) {
                statusIndicator.classList.remove('visible'); 
                setTimeout(() => {
                    statusIndicator.textContent = text;
                    statusIndicator.classList.add('visible'); 
                }, 150); 
            } else if (!isCurrentlyVisible) {
                statusIndicator.textContent = text;
                statusIndicator.classList.add('visible');
            } else {
                statusIndicator.textContent = text; 
                 if (!isCurrentlyVisible) statusIndicator.classList.add('visible');
            }
        }
    }
    function updateGameTimerDisplay() {
        if (!gameActive || !gameStartTime || isViewingHistoryState) {
            if (gameTimerInterval) clearInterval(gameTimerInterval);
            gameTimerInterval = null;
            return;
        }
        elapsedSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
    }

    function initBoard() {
        const board = document.getElementById('board'); board.innerHTML = '';
        board.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;
        for (let i = 0; i < ROWS; i++) {
            const rowDiv = document.createElement('div'); rowDiv.className = 'row';
            rowDiv.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
            for (let j = 0; j < COLS; j++) {
                const tileDiv = document.createElement('div'); 
                tileDiv.className = 'tile tile-new-game-appear'; 
                tileDiv.id = `tile-${i}-${j}`;
                tileDiv.style.animationDelay = `${i * 0.05 + j * 0.02}s`;
                rowDiv.appendChild(tileDiv);
            }
            board.appendChild(rowDiv);
        }
        setTimeout(() => {
            document.querySelectorAll('.tile-new-game-appear').forEach(t => t.classList.remove('tile-new-game-appear'));
        }, ROWS * 0.05 * 1000 + COLS * 0.02 * 1000 + 500);
    }

    function isTouchDevice() { return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); }
    function initKeyboard() {
        const keyboard = document.getElementById('keyboard'); keyboard.innerHTML = '';
        const keyLayout = [ ['1','2','3','4','5','6','7','8','9','0'], ['+','-','×','÷','%','^','>','!'], ['A','(',')','[',']','='], ['AC','删除','提交'] ];
        keyLayout.forEach((rowKeys) => {
            const rowDiv = document.createElement('div'); rowDiv.className = 'keyboard-row';
            rowKeys.forEach(keyText => {
                const key = document.createElement('div'); key.className = 'key'; key.textContent = keyText;
                let internalKeyValue = keyText;
                if (keyText === '×') internalKeyValue = '*'; if (keyText === '÷') internalKeyValue = '/';
                if (keyText === 'AC') { key.classList.add('wide'); key.addEventListener('click', handleClearAllCurrentRow); }
                else if (keyText === '删除') { key.classList.add('wide'); key.addEventListener('click', handleDelete); }
                else if (keyText === '提交') { key.classList.add('super-wide'); key.addEventListener('click', handleSubmit); }
                else { key.dataset.char = internalKeyValue; key.addEventListener('click', (event) => handleKeyPress(internalKeyValue, event.currentTarget)); }
                addKeyAnimationListeners(key); 
                if (keyTooltips[internalKeyValue]) {
                    key.classList.add('operator-key');
                    const tooltipSpan = document.createElement('span'); tooltipSpan.className = 'key-tooltip';
                    tooltipSpan.textContent = keyTooltips[internalKeyValue]; key.appendChild(tooltipSpan);
                    key.addEventListener('mouseenter', () => { if (!isTouchDevice()) key.classList.add('show-tooltip'); });
                    key.addEventListener('mouseleave', () => { if (!isTouchDevice()) key.classList.remove('show-tooltip'); });
                    key.addEventListener('touchstart', (e) => {
                        if (isTouchDevice()) { if (activeTooltipKey && activeTooltipKey !== key) activeTooltipKey.classList.remove('show-tooltip');
                            clearTimeout(activeTooltipTimeout); key.classList.add('show-tooltip'); activeTooltipKey = key;
                            activeTooltipTimeout = setTimeout(() => { if (activeTooltipKey === key) { key.classList.remove('show-tooltip'); activeTooltipKey = null;}}, 2500);}}, { passive: true }); }
                rowDiv.appendChild(key); }); keyboard.appendChild(rowDiv); }); }
    function addKeyAnimationListeners(keyEl) {
        keyEl.addEventListener('mousedown', () => keyEl.classList.add('pressed'));
        keyEl.addEventListener('mouseup', () => keyEl.classList.remove('pressed'));
        keyEl.addEventListener('mouseleave', () => {
            keyEl.classList.remove('pressed'); if (isTouchDevice() && activeTooltipKey === keyEl) return;
            keyEl.classList.remove('show-tooltip'); });
        keyEl.addEventListener('touchstart', (e) => { keyEl.classList.add('pressed');}, {passive: true});
        keyEl.addEventListener('touchend', () => keyEl.classList.remove('pressed')); }
    function resetKeyboardColors() { document.querySelectorAll('.key').forEach(k => k.classList.remove('correct','present','absent', 'disabled-permanently', 'disabled-view-mode')); }
    
    function startGame(newTargetEquation, newDifficultyKey) {
        gameActive = true; currentRow = 0; currentCol = 0;
        isViewingHistoryState = false; viewingHistoryItem = null;
        guessedEquationsHistory = []; gameStartTime = 0; elapsedSeconds = 0;
        if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null;
        enableKeyboardForPlay();
        restartBtn.title = "重新开始/投降"; restartBtn.innerHTML = '🔄';

        if (newTargetEquation && newDifficultyKey && difficultySetting[newDifficultyKey]) {
            targetEquation = newTargetEquation; currentDifficulty = newDifficultyKey; isCustomLevel = true; 
        } else {
            isCustomLevel = false; 
            const savedDiff = localStorage.getItem('sumzleDifficulty');
            if (difficultySetting[savedDiff]) currentDifficulty = savedDiff;
            else currentDifficulty = 'medium'; 
            targetEquation = generateRandomEquation(); }
        
        ROWS = difficultySetting[currentDifficulty].attempts; COLS = targetEquation.length;
        guessedEquation = Array(COLS).fill('');
        initBoard(); initKeyboard(); resetKeyboardColors(); updateDifficultyDisplay();
        updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS}字符`);
        document.getElementById('exportImageBtn').style.display = 'none';
        document.getElementById('shareLevelBtn').style.display = isCustomLevel || !gameActive ? 'inline-block' : 'none';
    }
    
    function resetGame() { isCustomLevel = false; 
        const savedDiff = localStorage.getItem('sumzleDifficulty');
        if (difficultySetting[savedDiff]) currentDifficulty = savedDiff;
        else currentDifficulty = 'medium'; 
        ROWS = difficultySetting[currentDifficulty].attempts; startGame(null, null); }

    function updateStatsDisplay() {
        const lbls = ['简单','中等','困难','总体'];
        const pD = [stats.byDifficulty.easy.gamesPlayed, stats.byDifficulty.medium.gamesPlayed, stats.byDifficulty.hard.gamesPlayed, stats.total.gamesPlayed];
        const wD = [stats.byDifficulty.easy.gamesWon, stats.byDifficulty.medium.gamesWon, stats.byDifficulty.hard.gamesWon, stats.total.gamesWon];
        const data = { labels: lbls, datasets: [ { label: '已玩', data: pD, backgroundColor: 'rgba(201,180,88,0.6)', borderColor: 'rgba(201,180,88,1)', borderWidth:1 }, { label: '获胜', data: wD, backgroundColor: 'rgba(106,170,100,0.6)', borderColor: 'rgba(106,170,100,1)', borderWidth:1 } ] };
        const cfg = { type:'bar',data:data,options:{responsive:true,maintainAspectRatio:false,scales:{y:{beginAtZero:true,grace:'5%'}},plugins:{title:{display:true,text:`最佳连胜: ${stats.total.bestStreak} | 当前连胜: ${stats.total.currentStreak}`,font:{size:14}},tooltip:{callbacks:{afterLabel: (ctx)=>{if(ctx.datasetIndex===1){const pl=pD[ctx.dataIndex];const wn=wD[ctx.dataIndex];return `胜率: ${pl>0?Math.round((wn/pl)*100):0}%`;}}}}}}};
        const chartEl = document.getElementById('statsChart');
        if(statsChartInstance) statsChartInstance.destroy();
        if(chartEl) statsChartInstance = new Chart(chartEl,cfg);
        const gpEl=document.getElementById('gamesPlayed'); if(gpEl)gpEl.textContent=stats.total.gamesPlayed;
        const gwEl=document.getElementById('gamesWon'); if(gwEl)gwEl.textContent=stats.total.gamesWon;
        const csEl=document.getElementById('currentStreak'); if(csEl)csEl.textContent=stats.total.currentStreak;
    }
    function clearStatistics() { showModal('confirmClearStatsModal');}
    document.getElementById('executeClearStatsBtn').addEventListener('click', () => {
        stats = JSON.parse(JSON.stringify(initialStats)); saveStats(); updateStatsDisplay();
        hideModal('confirmClearStatsModal'); showMessage("统计数据已清空"); });
    document.getElementById('cancelClearStatsBtn').addEventListener('click', () => { hideModal('confirmClearStatsModal'); });

    function handleKeyPress(char, keyElement = null) {
        if (!gameActive || currentCol >= COLS || isViewingHistoryState) return;
        if (keyElement && keyElement.classList.contains('disabled-permanently')) return;
        const tile = document.getElementById(`tile-${currentRow}-${currentCol}`); if (!tile) return;
        guessedEquation[currentCol] = char; tile.textContent = displayChar(char);
        tile.classList.add('filled', 'pop'); setTimeout(() => tile.classList.remove('pop'), 150);
        const keyRect = keyElement ? keyElement.getBoundingClientRect() : null;
        const tileRect = tile.getBoundingClientRect();
        if (keyElement && window.getComputedStyle(keyElement).display !== 'none' && keyRect) {
            const flyingChar = document.createElement('div'); flyingChar.textContent = displayChar(char);
            flyingChar.classList.add('flying-char-effect'); const keyStyle = window.getComputedStyle(keyElement);
            flyingChar.style.fontSize = keyStyle.fontSize; flyingChar.style.fontWeight = keyStyle.fontWeight;
            flyingChar.style.fontFamily = keyStyle.fontFamily; flyingChar.style.padding = keyStyle.padding;
            flyingChar.style.backgroundColor = keyStyle.backgroundColor; flyingChar.style.color = keyStyle.color;
            flyingChar.style.borderRadius = keyStyle.borderRadius; flyingChar.style.left = `${keyRect.left}px`;
            flyingChar.style.top = `${keyRect.top}px`; flyingChar.style.width = `${keyRect.width}px`;
            flyingChar.style.height = `${keyRect.height}px`; document.body.appendChild(flyingChar);
            requestAnimationFrame(() => {
                const targetLeft = tileRect.left + (tileRect.width - keyRect.width) / 2;
                const targetTop = tileRect.top + (tileRect.height - keyRect.height) / 2;
                const translateX = targetLeft - keyRect.left; const translateY = targetTop - keyRect.top;
                flyingChar.style.transform = `translate(${translateX}px, ${translateY}px) scale(0.5)`;
                flyingChar.style.opacity = '0'; });
            flyingChar.addEventListener('transitionend', () => { if (flyingChar.parentElement) flyingChar.parentElement.removeChild(flyingChar);}, { once: true }); }
        currentCol++;
    }
    function handleClearAllCurrentRow() {
        if (!gameActive || currentCol === 0 || isViewingHistoryState) return;
        for (let col = currentCol - 1; col >= 0; col--) {
            const tile = document.getElementById(`tile-${currentRow}-${col}`);
            if (tile && tile.textContent !== '') {
                setTimeout(() => { tile.textContent = ''; tile.classList.remove('filled');
                    tile.classList.add('tile-cleared-animation');
                    setTimeout(() => tile.classList.remove('tile-cleared-animation'), 300);
                }, (currentCol - 1 - col) * 60); }
            guessedEquation[col] = ''; } currentCol = 0; }
    function handleDelete() {
        if (!gameActive || currentCol <= 0 || isViewingHistoryState) return; currentCol--; 
        guessedEquation[currentCol] = ''; const tile = document.getElementById(`tile-${currentRow}-${currentCol}`);
        tile.textContent = ''; tile.classList.remove('filled'); }
        function safeEval(expr) {
        let safeExpr = expr;
        for (let k=0; k<3; k++) {
            safeExpr = safeExpr.replace(/\[(.*?)\]/g, (match, innerExpr) => `truncate((${innerExpr}))`);
        }

        for (let i=0; i<3; i++) { 
             safeExpr = safeExpr.replace(/(\d+)A(\d+)/g, "permutation($1, $2)");
             safeExpr = safeExpr.replace(/(\d+)!/g, "factorial($1)");
             safeExpr = safeExpr.replace(/\((.+?)\)!/g, (match, innerExpr) => `factorial((${innerExpr}))`);
             safeExpr = safeExpr.replace(/\((.+?)\)A(\d+)/g, (match, innerExpr, n) => `permutation((${innerExpr}), ${n})`);
             safeExpr = safeExpr.replace(/(\d+)A\((.+?)\)/g, (match, m, innerExpr) => `permutation(${m}, (${innerExpr}))`);
             safeExpr = safeExpr.replace(/\((.+?)\)A\((.+?)\)/g, (match, innerM, innerN) => `permutation((${innerM}), (${innerN}))`);
        }
        
        safeExpr = safeExpr.replace(/\^/g, '**');

        const evalAllowedChars = /^[0-9+\-*/%()!^*.<>\sacefilmoprtun]+$/i; 
        if (!evalAllowedChars.test(safeExpr.replace(/,/g, ''))) {
            throw new Error("Invalid chars for eval.");
        }
        
        try {
            return Function('factorial', 'permutation', 'truncate', 'return (' + safeExpr + ')')(window.factorial, window.permutation, Math.trunc);
        } catch (e) {
            throw e; 
        }
    }
    function checkBrackets(exprString) {
        const stack = []; const map = { '(': ')', '[': ']' };
        for (let char of exprString) {
            if (char === '(' || char === '[') stack.push(char);
            else if (char === ')' || char === ']') {
                if (stack.length === 0) return false; 
                const lastOpen = stack.pop(); if (map[lastOpen] !== char) return false; } }
        return stack.length === 0; }
    function checkModuloOperation(exprString) {
        const parts = exprString.split('%');
        if (parts.length > 1) {
            for (let i = 1; i < parts.length; i++) {
                let divisorPart = ""; let depth = 0;
                for (let j = 0; j < parts[i].length; j++) {
                    const char = parts[i][j];
                    if (char === '(' || char === '[') depth++; else if (char === ')' || char === ']') depth--;
                    if (depth < 0) break; divisorPart += char;
                    if (depth === 0 && (j === parts[i].length - 1 || !'0123456789.()[]'.includes(parts[i][j+1])) ) break; }
                if (divisorPart) { try { const divVal = safeEval(divisorPart); if (divVal === 0 || !Number.isInteger(divVal)) return false; } catch (e) { return false; }
                } else return false; } } return true; }
    function isValidEquation(equationArray, isGenerationContext = false) {
        const cleanEquation = equationArray.join('');
        if (!isGenerationContext && cleanEquation.includes('.')) { showMessage("输入不能包含小数点"); return false; }
        if (!isGenerationContext && /(?<![\.\d])0\d+/.test(cleanEquation)) { showMessage("数字不能以0开头 (除非是0本身)"); return false; }
        if (!isGenerationContext && !checkModuloOperation(cleanEquation)) { showMessage("取模运算中除数不能为0或小数"); return false; }
        let mainOp = null, mainOpIndex = -1, depth = 0;
        for(let i = 0; i < cleanEquation.length; i++) {
            const char = cleanEquation[i];
            if (char === '(' || char === '[') depth++; else if (char === ')' || char === ']') depth--;
            else if (depth === 0 && (char === '=' || char === '>')) { 
                if (mainOp !== null) { if (!isGenerationContext) showMessage("只能有一个主操作符"); return false; } 
                mainOp = char; mainOpIndex = i; } }
        if (!mainOp) { if (!isGenerationContext) showMessage("必须包含 = 或 >"); return false; } 
        const leftSide = cleanEquation.substring(0, mainOpIndex); const rightSide = cleanEquation.substring(mainOpIndex + 1);
        if (leftSide.length === 0 || rightSide.length === 0) { if (!isGenerationContext) showMessage("操作符两边需有表达式"); return false; }
        if (!checkBrackets(leftSide) || !checkBrackets(rightSide)) { if (!isGenerationContext) showMessage("括号不匹配"); return false; }
        try {
            const evalLeft = safeEval(leftSide); const evalRight = safeEval(rightSide);
            if (typeof evalLeft !== 'number' || typeof evalRight !== 'number' || isNaN(evalLeft) || isNaN(evalRight)) {
                if (!isGenerationContext) showMessage("表达式计算结果无效"); return false; }
            let statementTrue = false;
            if (mainOp === '=') statementTrue = Math.abs(evalLeft - evalRight) < 0.0001;
            else if (mainOp === '>') statementTrue = evalLeft > evalRight; 
            if (!statementTrue) { if (!isGenerationContext) showMessage("等式/不等式不成立"); return false; }
            if (!Number.isInteger(evalLeft) || !Number.isInteger(evalRight)) {
                 if (Math.abs(evalLeft - Math.round(evalLeft)) > 0.0001 || Math.abs(evalRight - Math.round(evalRight)) > 0.0001) {
                    if (!isGenerationContext) showMessage("结果必须为整数"); return false; }}}
        catch (e) { if (!isGenerationContext) showMessage(`无效表达式: ${e.message}`); return false; } return true; }
    function triggerConfetti() {
        const confettiContainer = document.getElementById('confettiOverlay'); if (!confettiContainer) return;
        for (let i = 0; i < 60; i++) {
            const confettiPiece = document.createElement('div'); confettiPiece.classList.add('confetti-piece');
            confettiPiece.style.width = `${getRandomInt(6, 12)}px`; confettiPiece.style.height = confettiPiece.style.width;
            confettiPiece.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
            confettiPiece.style.left = `${Math.random() * 100}%`; confettiPiece.style.top = `${-20 - Math.random() * 30}%`;
            confettiPiece.style.opacity = '0'; confettiPiece.style.transform = `rotate(${Math.random() * 360}deg)`;
            const animationDuration = Math.random() * 2 + 4.0; 
            confettiPiece.style.transitionDuration = `${animationDuration}s, ${animationDuration}s, ${animationDuration * 0.4}s`;
            confettiContainer.appendChild(confettiPiece);
            setTimeout(() => { confettiPiece.style.opacity = '1'; confettiPiece.style.top = '110%'; 
                confettiPiece.style.transform = `rotate(${Math.random() * 720 + 360}deg) translateX(${Math.random()*150-75}px)`;
            }, 50 + Math.random() * 100); 
            setTimeout(() => { if (confettiPiece.parentElement) confettiPiece.parentElement.removeChild(confettiPiece);}, animationDuration * 1000 + 200);}}
    let messageTimeout;

    function handleEndGame(isWin, statusString) {
        gameActive = false;
        if (gameTimerInterval) clearInterval(gameTimerInterval); gameTimerInterval = null;
        
        let finalMessage = "";
        const displayTargetEquation = targetEquation.replace(/\*/g, '×').replace(/\//g, '÷');

        if (isWin) {
            if (!isCustomLevel || isViewingHistoryState) {
                stats.total.gamesPlayed++; stats.total.gamesWon++; stats.total.currentStreak++;
                stats.total.bestStreak = Math.max(stats.total.bestStreak, stats.total.currentStreak);
                stats.byDifficulty[currentDifficulty].gamesPlayed++; stats.byDifficulty[currentDifficulty].gamesWon++;
                saveStats();
            }
            finalMessage = `恭喜你猜对了！ 🎉`;
            if (elapsedSeconds > 0) updateStatusIndicatorText(`胜利! 用时: ${formatTime(elapsedSeconds)}`);
            else updateStatusIndicatorText(`胜利!`);
            triggerConfetti();
            document.getElementById('exportImageBtn').style.display = 'inline-block';
            document.getElementById('shareLevelBtn').style.display = 'inline-block';
        } else { 
            if (!isCustomLevel || isViewingHistoryState) {
                stats.total.gamesPlayed++; stats.total.currentStreak = 0;
                stats.byDifficulty[currentDifficulty].gamesPlayed++; saveStats();
            }
            if (statusString === 'SURRENDERED') finalMessage = `已放弃。答案: ${displayTargetEquation} 🙁`;
            else finalMessage = `游戏结束! 答案: ${displayTargetEquation} 🙁`;
            
            if (elapsedSeconds > 0) updateStatusIndicatorText(`失败。用时: ${formatTime(elapsedSeconds)}`);
            else updateStatusIndicatorText(`失败`);
            document.getElementById('exportImageBtn').style.display = 'none';
            document.getElementById('shareLevelBtn').style.display = 'inline-block';
        }
        
        showMessage(finalMessage, statusString === 'SURRENDERED' ? 3000 : 4000);
        updateStatsDisplay();

        const recordingDelay = (COLS * 100) + 400; 
        setTimeout(() => {
            recordGameInHistory(isWin, statusString);
        }, recordingDelay);
        
        setTimeout(() => showModal('gameOverModal', isWin), (COLS * 120) + (isWin ? 800 : 100));
    }

    function handleSubmit() {
        if (!gameActive || isViewingHistoryState) return;
        const currentBoardRowElement = document.querySelector(`.board .row:nth-child(${currentRow + 1})`);
        if (currentCol < COLS) {
            if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
            setTimeout(() => { if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake'); }, 500);
            showMessage("请填满当前行"); return; }
        if (!isValidEquation(guessedEquation)) {
            if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
            setTimeout(() => { if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake'); }, 500);
            return; }

        if (!gameStartTime && currentCol === COLS) { 
            gameStartTime = Date.now();
            elapsedSeconds = 0; 
            updateGameTimerDisplay(); 
        }
        guessedEquationsHistory.push(guessedEquation.join(''));
        checkGuess(); const guessString = guessedEquation.join('');
        
        if (guessString === targetEquation) {
            const tilesToDance = currentBoardRowElement ? Array.from(currentBoardRowElement.children) : [];
            tilesToDance.forEach((tile, i) => { setTimeout(() => tile.classList.add('win-dance'), i * 100); });
            handleEndGame(true, 'WON');
            return;
        }
        currentRow++; currentCol = 0; guessedEquation = Array(COLS).fill('');
        if (currentRow >= ROWS) {
            if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
            setTimeout(() => { if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake'); }, 600);
            handleEndGame(false, 'LOST');
        }
    }
    function checkGuess() {
        const targetChars = [...targetEquation]; const guessChars = [...guessedEquation]; const resultStates = Array(COLS).fill('absent');
        for (let i = 0; i < COLS; i++) if (guessChars[i] === targetChars[i]) { resultStates[i] = 'correct'; targetChars[i] = null; }
        for (let i = 0; i < COLS; i++) {
            if (resultStates[i] !== 'correct') {
                const indexInTarget = targetChars.indexOf(guessChars[i]);
                if (indexInTarget !== -1) { resultStates[i] = 'present'; targetChars[indexInTarget] = null; }}}
        const boardRow = document.querySelector(`.row:nth-child(${currentRow + 1})`);
        if (boardRow) {
            const tiles = boardRow.children;
            for (let i = 0; i < COLS; i++) {
                const tile = tiles[i];
                setTimeout(() => { tile.classList.add('flip-reveal'); 
                    setTimeout(() => { tile.classList.remove('absent','present','correct','filled'); 
                        tile.classList.add(resultStates[i]); tile.style.borderColor = ''; }, 350); 
                }, i * 100); } }
        updateKeyboardColors(guessChars, resultStates); }
    function updateKeyboardColors(chars, results) {
        for (let i = 0; i < chars.length; i++) {
            const char = chars[i]; const result = results[i]; if (!char) continue;
            document.querySelectorAll(`.key[data-char="${char}"]`).forEach(key => {
                const kcl = key.classList;
                if (char === '>' && result === 'absent' && !kcl.contains('correct') && !kcl.contains('present')) { 
                    kcl.add('disabled-permanently'); kcl.remove('present','correct','absent'); return; }
                if (kcl.contains('disabled-permanently')) return;
                if (result === 'correct') { kcl.remove('present','absent'); kcl.add('correct'); }
                else if (result === 'present' && !kcl.contains('correct')) { kcl.remove('absent'); kcl.add('present'); }
                else if (result === 'absent' && !kcl.contains('correct') && !kcl.contains('present')) kcl.add('absent'); });}}
    
    function showMessage(text, duration = 2000) {
        const msgEl = document.getElementById('message'); clearTimeout(messageTimeout);
        msgEl.textContent = text; msgEl.classList.remove('show-message'); 
        void msgEl.offsetWidth; msgEl.classList.add('show-message');
        messageTimeout = setTimeout(() => msgEl.classList.remove('show-message'), duration); }
    function showModal(modalId, isWinArgForGameOver) {
        const modal = document.getElementById(modalId); if (!modal) return;
        if (modalId === 'gameOverModal') {
            const title = document.getElementById('gameOverTitle'); const msg = document.getElementById('gameOverMessage');
            const displayTargetEquation = targetEquation.replace(/\*/g, '×').replace(/\//g, '÷');
            if (isWinArgForGameOver) { title.innerHTML = '🏆 恭喜！🏆'; msg.textContent = `你用了 ${currentRow+1} 次猜中: ${displayTargetEquation}`; }
            else { title.innerHTML = '💔 游戏结束 💔'; msg.textContent = `正确答案: ${displayTargetEquation}`; } }
        modal.style.display = 'flex'; void modal.offsetWidth; modal.classList.add('show'); }
    function hideModal(modalId) {
        const modal = document.getElementById(modalId); if (!modal || !modal.classList.contains('show')) return;
        modal.classList.remove('show'); setTimeout(() => modal.style.display = 'none', 350); }
    function saveStats() { localStorage.setItem('sumzleStats', JSON.stringify(stats)); }
    function saveDifficulty() { localStorage.setItem('sumzleDifficulty', currentDifficulty); }

    document.getElementById('newGameBtn').addEventListener('click', () => { hideModal('gameOverModal'); resetGame(); });
    
    restartBtn.addEventListener('click', handleRestartOrExitView);

    function handleRestartOrExitView() {
        if (isViewingHistoryState) {
            exitHistoryView();
        } else {
            if (gameActive && (currentRow > 0 || currentCol > 0 || isCustomLevel) ) {
                 showModal('surrenderModal');
            } else {
                 resetGame();
            }
        }
    }

    document.getElementById('confirmSurrenderBtn').addEventListener('click', () => {
        hideModal('surrenderModal');
        handleEndGame(false, 'SURRENDERED');
    });
    document.getElementById('cancelSurrenderBtn').addEventListener('click', () => hideModal('surrenderModal'));

    const menuToggleBtn = document.getElementById('menuToggleBtn');
    const headerButtonsGroup = document.getElementById('headerButtonsGroup');
    if(menuToggleBtn) menuToggleBtn.addEventListener('click', (event) => {
        event.stopPropagation(); headerButtonsGroup.classList.toggle('show-menu');
        menuToggleBtn.classList.toggle('active'); });
    document.addEventListener('click', (event) => {
        if (headerButtonsGroup && headerButtonsGroup.classList.contains('show-menu') && !headerButtonsGroup.contains(event.target) && event.target !== menuToggleBtn) {
            headerButtonsGroup.classList.remove('show-menu'); if (menuToggleBtn) menuToggleBtn.classList.remove('active');}
        if (activeTooltipKey && isTouchDevice() && event.target !== activeTooltipKey && !activeTooltipKey.contains(event.target)) {
             clearTimeout(activeTooltipTimeout); activeTooltipKey.classList.remove('show-tooltip'); activeTooltipKey = null;}});
    document.getElementById('settingsBtn').addEventListener('click', () => { showModal('settingsModal'); });
    document.getElementById('closeSettingsBtn').addEventListener('click', () => hideModal('settingsModal'));
    document.getElementById('statsBtn').addEventListener('click', () => { updateStatsDisplay(); showModal('statsModal'); });
    document.getElementById('closeStatsBtn').addEventListener('click', () => hideModal('statsModal'));
    document.getElementById('clearStatsBtn').addEventListener('click', clearStatistics);
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            isCustomLevel = false; currentDifficulty = btn.dataset.difficulty; 
            ROWS = difficultySetting[currentDifficulty].attempts; saveDifficulty(); 
            resetGame(); hideModal('settingsModal'); }); });
    document.addEventListener('keydown', (e) => {
        let activeModalId = null; document.querySelectorAll('.modal.show').forEach(m => activeModalId = m.id);
        if (e.key === 'Escape' && activeModalId) { e.preventDefault(); hideModal(activeModalId); return; }
        const isTypingInModal = activeModalId === 'loadLevelModal' && document.activeElement === document.getElementById('levelCodeInput');
        if (activeModalId && !isTypingInModal && e.key !== 'Enter') return;
        if (validChars.includes(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey && e.key.length === 1) {
             if(!activeModalId || (activeModalId === 'loadLevelModal' && !isTypingInModal) ) { 
                e.preventDefault(); const keyElement = document.querySelector(`.key[data-char="${e.key}"]`);
                handleKeyPress(e.key, keyElement); }}
        else if (e.key === 'Backspace') { 
            if(!activeModalId || (activeModalId === 'loadLevelModal' && !isTypingInModal) ) { 
                e.preventDefault(); handleDelete(); }}
        else if (e.key === 'Enter') {
            e.preventDefault();
            if (activeModalId === 'gameOverModal') document.getElementById('newGameBtn').click();
            else if (activeModalId === 'settingsModal') document.getElementById('closeSettingsBtn').click();
            else if (activeModalId === 'statsModal') document.getElementById('closeStatsBtn').click();
            else if (activeModalId === 'loadLevelModal') document.getElementById('submitLoadLevelBtn').click();
            else if (activeModalId === 'surrenderModal') document.getElementById('confirmSurrenderBtn').click(); 
            else if (activeModalId === 'confirmClearStatsModal') document.getElementById('executeClearStatsBtn').click();
            else if (activeModalId === 'historyModal') document.getElementById('closeHistoryModalBtn').click();
            else if (activeModalId === 'confirmClearHistoryModal') document.getElementById('executeClearHistoryBtn').click();
            else if (gameActive && !isViewingHistoryState) handleSubmit();}});

    function captureFinalBoardRender() {
        const render = [];
        const rowsToCapture = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.finalBoardRender.length : (gameActive ? currentRow + 1 : ROWS);
        for (let r = 0; r < rowsToCapture; r++) {
            if (r >= ROWS) break; 
            const rowRender = []; const rowElement = document.querySelector(`.board .row:nth-child(${r + 1})`);
            if (!rowElement) { render.push(Array(COLS).fill(null)); continue; }
            for (let c = 0; c < COLS; c++) {
                const tile = rowElement.children[c];
                if (tile) rowRender.push({ text: tile.textContent, classList: Array.from(tile.classList)});
                else rowRender.push(null);
            } render.push(rowRender);
        } return render;
    }
    function captureKeyboardState() {
        const keyboardState = {};
        document.querySelectorAll('.key[data-char]').forEach(key => {
            const char = key.dataset.char;
            if (key.classList.contains('correct')) keyboardState[char] = 'correct';
            else if (key.classList.contains('present')) keyboardState[char] = 'present';
            else if (key.classList.contains('absent')) keyboardState[char] = 'absent';
            else if (key.classList.contains('disabled-permanently')) keyboardState[char] = 'disabled-permanently';
        }); return keyboardState;
    }
    function recordGameInHistory(isWin, finalStatus) {
        if (isCustomLevel && finalStatus === 'SURRENDERED' && !isWin) return; 
        const finalBoardRender = captureFinalBoardRender();
        const keyboardState = captureKeyboardState();
        const historyEntry = {
            id: Date.now().toString(36) + Math.random().toString(36).substring(2),
            timestamp: Date.now(), targetEquation: targetEquation, difficulty: currentDifficulty,
            status: finalStatus, attemptsMade: currentRow + (isWin || finalStatus === 'LOST' || finalStatus === 'SURRENDERED' ? 1 : 0), 
            timeTaken: elapsedSeconds > 0 ? elapsedSeconds : null,
            finalBoardRender: finalBoardRender, keyboardState: keyboardState,
            guessedRows: [...guessedEquationsHistory] };
        let gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];
        gameHistory.unshift(historyEntry); if (gameHistory.length > 50) gameHistory.length = 50; 
        localStorage.setItem('sumzleGameHistory', JSON.stringify(gameHistory));
    }
    
    function disableKeyboardForView() {
        document.querySelectorAll('.key').forEach(key => {
            if (key.dataset.char || key.textContent === '提交' || key.textContent === 'AC' || key.textContent === '删除') {
                key.classList.add('disabled-view-mode');
            }
        });
    }
    function enableKeyboardForPlay() {
         document.querySelectorAll('.key.disabled-view-mode').forEach(key => {
            key.classList.remove('disabled-view-mode');
        });
    }
    function applyHistoricalBoardState(item) {
        item.finalBoardRender.forEach((rowRenderData, r) => {
            if (r >= ROWS) return;
            rowRenderData.forEach((tileRenderData, c) => {
                if (c >= COLS) return;
                const tileElement = document.getElementById(`tile-${r}-${c}`);
                if (tileElement && tileRenderData) {
                    tileElement.textContent = tileRenderData.text;
                    tileElement.className = 'tile'; 
                    tileRenderData.classList.forEach(cls => { if(cls !== 'tile-new-game-appear' && cls !== 'pop') tileElement.classList.add(cls); });
                }
            });
        });
        resetKeyboardColors(); 
        Object.entries(item.keyboardState).forEach(([char, state]) => {
            document.querySelectorAll(`.key[data-char="${char}"]`).forEach(key => {
                if (state) { key.classList.remove('correct', 'present', 'absent', 'disabled-permanently'); key.classList.add(state); }});});
    }
    function exitHistoryView() {
        isViewingHistoryState = false; viewingHistoryItem = null;
        restartBtn.title = "重新开始/投降"; restartBtn.innerHTML = '🔄';
        enableKeyboardForPlay();
        document.getElementById('exportImageBtn').style.display = 'none';
        document.getElementById('shareLevelBtn').style.display = 'none';
        resetGame();
    }
    function loadHistoryItemState(item) {
        isViewingHistoryState = true; viewingHistoryItem = item; gameActive = false;
        currentDifficulty = item.difficulty; targetEquation = item.targetEquation;
        ROWS = difficultySetting[currentDifficulty].attempts; COLS = targetEquation.length;
        initBoard(); initKeyboard();
        applyHistoricalBoardState(item);
        currentRow = item.attemptsMade -1; 
        updateStatusIndicatorText(
            `${item.status === 'WON' ? '查看胜利' : (item.status === 'LOST' ? '查看失败' : '查看记录')} (${difficultySetting[item.difficulty].name})${item.timeTaken ? ' - 用时: ' + formatTime(item.timeTaken) : ''}`
        );
        disableKeyboardForView();
        restartBtn.title = "关闭查看"; restartBtn.innerHTML = '❌';
        document.getElementById('exportImageBtn').style.display = 'inline-block';
        document.getElementById('shareLevelBtn').style.display = 'inline-block';
        hideModal('historyModal');
    }

    function displayHistory() {
        const historyListContainer = document.getElementById('historyListContainer');
        const noHistoryMsg = document.getElementById('noHistoryMessage');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        historyListContainer.innerHTML = '';
        const gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];

        if (gameHistory.length === 0) {
            noHistoryMsg.style.display = 'block';
            clearHistoryBtn.style.display = 'none';
            return;
        }
        noHistoryMsg.style.display = 'none';
        clearHistoryBtn.style.display = 'inline-block';

        gameHistory.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'history-item';
            itemDiv.dataset.historyId = item.id;
            const statusClass = item.status ? item.status.toLowerCase() : 'unknown';
            const statusText = item.status === 'WON' ? '胜利' : (item.status === 'LOST' ? '失败' : (item.status === 'SURRENDERED' ? '放弃' : '未知'));

            itemDiv.innerHTML = `
                <div class="history-item-preview">
                    <span class="history-equation">${item.targetEquation.replace(/\*/g, '×').replace(/\//g, '÷')}</span>
                    <span class="history-status ${statusClass}">${statusText}</span>
                </div>
                <div class="history-item-details">
                    <span>${difficultySetting[item.difficulty].name}</span> | <span>${new Date(item.timestamp).toLocaleDateString()} ${new Date(item.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                    ${item.timeTaken !== null ? `| <span>用时: ${formatTime(item.timeTaken)}</span>` : ''}
                    <span>(${item.attemptsMade} / ${difficultySetting[item.difficulty].attempts} 次尝试)</span>
                </div>
                <div class="history-item-actions">
                    <button class="history-replay-btn secondary-btn">重玩</button>
                    <button class="history-view-state-btn primary-btn">查看</button>
                    <button class="history-delete-btn danger-btn">删除</button>
                </div>
            `;
            itemDiv.querySelector('.history-replay-btn').addEventListener('click', () => {
                isCustomLevel = true; 
                startGame(item.targetEquation, item.difficulty);
                hideModal('historyModal');
            });
            itemDiv.querySelector('.history-view-state-btn').addEventListener('click', () => loadHistoryItemState(item));
            itemDiv.querySelector('.history-delete-btn').addEventListener('click', () => {
                let updatedHistory = gameHistory.filter(h => h.id !== item.id);
                localStorage.setItem('sumzleGameHistory', JSON.stringify(updatedHistory));
                displayHistory(); 
            });
            historyListContainer.appendChild(itemDiv);
        });
    }

    document.getElementById('historyBtn').addEventListener('click', () => {
        displayHistory();
        showModal('historyModal');
    });
    document.getElementById('closeHistoryModalBtn').addEventListener('click', () => hideModal('historyModal'));
    document.getElementById('clearHistoryBtn').addEventListener('click', () => showModal('confirmClearHistoryModal'));
    document.getElementById('executeClearHistoryBtn').addEventListener('click', () => {
        localStorage.removeItem('sumzleGameHistory');
        displayHistory();
        hideModal('confirmClearHistoryModal');
        showMessage("游戏历史已清空");
    });
    document.getElementById('cancelClearHistoryBtn').addEventListener('click', () => hideModal('confirmClearHistoryModal'));

    function exportGameImage() {
        const gameBoardElement = document.getElementById('board');
        const headerElement = document.querySelector('header');
        const tempContainer = document.createElement('div');
        tempContainer.style.padding = '20px'; tempContainer.style.paddingTop = '30px'; 
        tempContainer.style.paddingBottom = '30px'; tempContainer.style.backgroundColor = getComputedStyle(document.body).backgroundColor;
        tempContainer.style.width = 'max-content'; tempContainer.style.minWidth = '350px'; 
        const titleClone = headerElement.querySelector('.header-title').cloneNode(true);
        titleClone.style.position = 'static'; titleClone.style.transform = 'none'; titleClone.style.left = 'auto';
        titleClone.style.textAlign = 'center'; titleClone.style.width = '100%'; titleClone.style.marginBottom = '25px';
        titleClone.style.fontSize = '1.8rem'; titleClone.style.fontWeight = 'bold';
        const boardClone = gameBoardElement.cloneNode(true);
        boardClone.id = 'boardCloneForExport'; boardClone.style.overflow = 'visible';
        boardClone.style.maxWidth = 'none'; boardClone.style.width = gameBoardElement.scrollWidth + 'px';
        const originalTiles = gameBoardElement.querySelectorAll('.tile');
        const clonedTiles = boardClone.querySelectorAll('.tile');
        clonedTiles.forEach((clonedTile, index) => {
            const originalTile = originalTiles[index];
            if (originalTile) {
                const computedStyle = window.getComputedStyle(originalTile);
                clonedTile.style.backgroundColor = computedStyle.backgroundColor;
                clonedTile.style.color = computedStyle.color; clonedTile.style.borderColor = computedStyle.borderColor;
                clonedTile.style.borderStyle = computedStyle.borderStyle; clonedTile.style.borderWidth = computedStyle.borderWidth;
                clonedTile.textContent = originalTile.textContent; clonedTile.style.transform = 'none'; 
                clonedTile.style.animation = 'none'; 
                clonedTile.classList.remove('win-dance', 'flip-reveal', 'pop', 'filled');
                if (originalTile.classList.contains('correct')) clonedTile.classList.add('correct');
                else if (originalTile.classList.contains('present')) clonedTile.classList.add('present');
                else if (originalTile.classList.contains('absent')) clonedTile.classList.add('absent'); }});
        const exportMessage = document.createElement('p');
        let difficultyText = difficultySetting[currentDifficulty].name;
        let attemptsInfo;
        if (isViewingHistoryState && viewingHistoryItem) {
            const itemStatusText = viewingHistoryItem.status === 'WON' ? '胜利' : (viewingHistoryItem.status === 'LOST' ? '失败' : '记录');
            attemptsInfo = `${viewingHistoryItem.attemptsMade}/${difficultySetting[viewingHistoryItem.difficulty].attempts} (${itemStatusText})`;
            if (viewingHistoryItem.timeTaken) attemptsInfo += ` - 用时: ${formatTime(viewingHistoryItem.timeTaken)}`;
        } else {
            attemptsInfo = `${currentRow + 1}/${ROWS} 尝试`;
            if (elapsedSeconds > 0 && !gameActive) attemptsInfo += ` - 用时: ${formatTime(elapsedSeconds)}`;
        }
        exportMessage.textContent = `Sumzle ${difficultyText} - ${attemptsInfo}`;
        exportMessage.style.textAlign = 'center'; exportMessage.style.marginTop = '25px';
        exportMessage.style.fontWeight = 'bold'; exportMessage.style.fontSize = '1rem';
        exportMessage.style.color = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();
        tempContainer.appendChild(titleClone); tempContainer.appendChild(boardClone); tempContainer.appendChild(exportMessage);
        document.body.appendChild(tempContainer);
        html2canvas(tempContainer, {
            backgroundColor: getComputedStyle(document.body).backgroundColor, useCORS: true,
            scale: window.devicePixelRatio * 1.3, width: tempContainer.scrollWidth + 50,
            height: tempContainer.scrollHeight, windowWidth: tempContainer.scrollWidth,
            windowHeight: tempContainer.scrollHeight, logging: false, 
            onclone: (clonedDocument) => {
                const clonedBoardInDoc = clonedDocument.getElementById('boardCloneForExport');
                if (clonedBoardInDoc) clonedBoardInDoc.querySelectorAll('.tile').forEach(tile => {
                    tile.style.animation = 'none !important'; tile.style.transform = 'none !important';
                    tile.classList.remove('win-dance', 'flip-reveal', 'pop');});}}
        ).then(canvas => {
            const image = canvas.toDataURL("image/png"); const link = document.createElement('a');
            link.href = image; link.download = `Sumzle_Game_${new Date().toISOString().slice(0,10)}.png`;
            link.click(); document.body.removeChild(tempContainer); showMessage("图片已导出!", 2000);
        }).catch(err => { console.error("html2canvas error during export:", err); 
            showMessage("导出图片失败. 查看控制台获取详情.", 3000);
            if (tempContainer.parentElement) document.body.removeChild(tempContainer);});}
    document.getElementById('exportImageBtn').addEventListener('click', () => { exportGameImage();});
    function fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea"); textArea.value = text;
        textArea.style.position = "fixed"; textArea.style.top = "0"; textArea.style.left = "0";
        textArea.style.width = "2em"; textArea.style.height = "2em"; textArea.style.padding = "0";
        textArea.style.border = "none"; textArea.style.outline = "none"; textArea.style.boxShadow = "none";
        textArea.style.background = "transparent"; document.body.appendChild(textArea);
        textArea.focus(); textArea.select();
        try { const successful = document.execCommand('copy');
            if (successful) showMessage("关卡代码已复制!"); else showMessage("复制失败.");
        } catch (err) { showMessage("复制失败: " + err); }
        document.body.removeChild(textArea);}
    document.getElementById('shareLevelBtn').addEventListener('click', () => {
        const encoded = encodeLevel(targetEquation, currentDifficulty); 
        if (encoded) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(encoded)
                    .then(() => showMessage("关卡代码已复制!"))
                    .catch(err => { console.warn("Clipboard API failed, trying fallback: ", err); fallbackCopyTextToClipboard(encoded); });
            } else fallbackCopyTextToClipboard(encoded);
        } else showMessage("生成分享代码失败!");});
    document.getElementById('loadLevelBtn').addEventListener('click', () => { showModal('loadLevelModal');});
    document.getElementById('closeLoadLevelModalBtn').addEventListener('click', () => {
        document.getElementById('levelCodeInput').value = ''; hideModal('loadLevelModal'); });
    document.getElementById('submitLoadLevelBtn').addEventListener('click', () => {
        const code = document.getElementById('levelCodeInput').value;
        if (code) {
            const decodedData = decodeLevel(code.trim());
            if (decodedData && decodedData.equation.length >= MIN_EQUATION_LENGTH && decodedData.equation.length <= MAX_EQUATION_LENGTH &&
                isValidEquation(decodedData.equation.split(''), true)) {
                isCustomLevel = true; startGame(decodedData.equation, decodedData.difficulty); saveDifficulty(); 
                hideModal('loadLevelModal'); document.getElementById('levelCodeInput').value = ''; 
                showMessage(`已载入 ${difficultySetting[decodedData.difficulty].name} 难度分享关卡!`);
            } else showMessage("无效或已损坏的关卡代码。"); }});
    updateStatsDisplay(); resetGame(); 
});
</script>
</body>
</html>