<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumzle</title>
    <script src="https://cdn.staticfile.net/Chart.js/3.9.1/chart.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @property --current-title-color-1 {
            syntax: '<color>';
            inherits: false;
            initial-value: #4facfe;
        }

        @property --current-title-color-2 {
            syntax: '<color>';
            inherits: false;
            initial-value: #00f2fe;
        }

        @property --current-title-color-3 {
            syntax: '<color>';
            inherits: false;
            initial-value: #43e97b;
        }

        @property --current-animation-angle {
            syntax: '<angle>';
            inherits: false;
            initial-value: 120deg;
        }

        :root {
            --font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-border-light: #f1f3f5;
            --color-divider: #e9ecef;
            --color-correct: #28a745;
            --color-present: #ffc107;
            --color-absent: #7a7a7a;
            --color-key-feedback-text: #ffffff;
            --color-easy: #17a2b8;
            --color-medium: #fd7e14;
            --color-hard: #dc3545;
            --fluent-blue: #007bff;
            --fluent-blue-hover: #0069d9;
            --fluent-blue-active: #0056b3;
            --tile-border-radius: 6px;
            --key-border-radius: 6px;
            --modal-border-radius: 8px;
            --button-border-radius: 5px;
            --shadow-xs: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-s: 0 2px 4px rgba(0,0,0,0.07);
            --shadow-m: 0 4px 8px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.06);
            --shadow-l: 0 8px 16px rgba(0,0,0,0.1), 0 0 2px rgba(0,0,0,0.07);
            --shadow-xl: 0 12px 24px rgba(0,0,0,0.12), 0 0 3px rgba(0,0,0,0.08);
            --color-key-default-bg: #f1f3f5;
            --color-key-default-border: #ced4da;
            --color-key-default-text: var(--color-text);
            --color-key-default-hover-bg: #e9ecef;
            --color-key-default-active-bg: #dee2e6;
            --color-btn-secondary-bg: #e9ecef;
            --color-btn-secondary-text: var(--color-text);
            --color-btn-secondary-border: var(--color-border);
            --color-btn-secondary-hover-bg: #dee2e6;
            --color-btn-secondary-hover-border: #ced4da;
            --color-btn-secondary-active-bg: #ced4da;
            --color-input-bg: var(--color-background);
            --color-input-text: var(--color-text);
            --color-input-border: var(--color-border);
            --color-input-focus-border: var(--fluent-blue);
            --color-input-focus-shadow: rgba(0,123,255,0.25);
            --chart-grid-color: rgba(0,0,0,0.1);
            --chart-tick-color: #666;
            --chart-title-color: #333;
            --chart-legend-label-color: #333;
            --title-grad-win-1: #28a745;
            --title-grad-win-2: #84fab0;
            --title-grad-win-3: #ffc107;
            --title-grad-lose-1: #d32f2f;
            --title-grad-lose-2: #ff6b6b;
            --title-grad-lose-3: #757575;
            --title-grad-custom-1: #6a11cb;
            --title-grad-custom-2: #2575fc;
            --title-grad-custom-3: #00dbde;
            --title-grad-history-1: #ff9a9e;
            --title-grad-history-2: #fad0c4;
            --title-grad-history-3: #fbc2eb;
            --title-grad-debug-1: #ff00ff;
            --title-grad-debug-2: #00ffff;
            --title-grad-debug-3: #ffff00;
            --title-grad-quark-1: #8A2BE2;
            --title-grad-quark-2: #4B0082;
            --title-grad-quark-3: #DA70D6;
        }

        body.dark-theme {
            --color-background: #1a1a1d;
            --color-surface: #2c2f33;
            --color-text: #f0f0f0;
            --color-text-secondary: #a0a0a0;
            --color-border: #424549;
            --color-border-light: #36393f;
            --color-divider: #36393f;
            --color-key-default-bg: #4f545c;
            --color-key-default-border: #40444b;
            --color-key-default-text: #dcddde;
            --color-key-default-hover-bg: #5c6168;
            --color-key-default-active-bg: #696e75;
            --color-btn-secondary-bg: #4f545c;
            --color-btn-secondary-text: #e0e0e0;
            --color-btn-secondary-border: #40444b;
            --color-btn-secondary-hover-bg: #5c6168;
            --color-btn-secondary-hover-border: #4f545c;
            --color-btn-secondary-active-bg: #696e75;
            --color-input-bg: #36393f;
            --color-input-text: #e0e0e0;
            --color-input-border: #424549;
            --color-input-focus-border: var(--fluent-blue-hover);
            --color-input-focus-shadow: rgba(0,105,217,0.35);
            --chart-grid-color: rgba(255,255,255,0.1);
            --chart-tick-color: #e0e0e0;
            --chart-title-color: #f0f0f0;
            --chart-legend-label-color: #f0f0f0;
            --title-grad-win-1: #30c753;
            --title-grad-win-2: #a2facf;
            --title-grad-win-3: #ffd027;
            --title-grad-lose-1: #ef5350;
            --title-grad-lose-2: #ff8a80;
            --title-grad-lose-3: #bdbdbd;
            --title-grad-custom-1: #834d9b;
            --title-grad-custom-2: #3067c4;
            --title-grad-custom-3: #00c9cb;
            --title-grad-history-1: #f4a7a9;
            --title-grad-history-2: #fcd6ce;
            --title-grad-history-3: #fdd5ef;
            --title-grad-debug-1: #ff33ff;
            --title-grad-debug-2: #33ffff;
            --title-grad-debug-3: #ffff33;
            --title-grad-quark-1: #9F2B68; 
            --title-grad-quark-2: #702963;
            --title-grad-quark-3: #C9A0DC;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            touch-action: manipulation;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background-color .3s ease-in-out,color .3s ease-in-out
        }

        #dynamicBackgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            display: block
        }

        header {
            width: 100%;
            padding: 10px 0;
            border-bottom: 1px solid var(--color-divider);
            text-align: center;
            font-weight: 600;
            font-size: 1.6rem;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--color-surface);
            min-height: 60px;
            box-sizing: border-box;
            box-shadow: var(--shadow-s);
            z-index: 10;
            transition: background-color .3s ease-in-out,border-bottom-color .3s ease-in-out
        }

        .header-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 800;
            font-size: 2.2rem;
            font-family: "Segoe UI Black","Arial Black",var(--font-family);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(var(--current-animation-angle,120deg),var(--current-title-color-1),var(--current-title-color-2),var(--current-title-color-3),var(--current-title-color-2),var(--current-title-color-1));
            background-size: 400% 400%;
            animation: titleShimmer 8s cubic-bezier(.65,.05,.36,1) infinite alternate;
            transition: --current-title-color-1 .8s cubic-bezier(.25,.1,.25,1),--current-title-color-2 .8s cubic-bezier(.25,.1,.25,1),--current-title-color-3 .8s cubic-bezier(.25,.1,.25,1),--current-animation-angle .8s cubic-bezier(.25,.1,.25,1),filter .8s cubic-bezier(.25,.1,.25,1),animation-duration .8s cubic-bezier(.25,.1,.25,1), top .8s cubic-bezier(0.6, -0.28, 0.735, 0.045), opacity .5s ease-out;
            letter-spacing: 1px;
            will-change: background-position,filter,--current-title-color-1,--current-title-color-2,--current-title-color-3,--current-animation-angle,animation-duration, top, opacity;
            cursor: pointer;
        }

        .title-char {
            display: inline-block;
        }

        @keyframes titleShimmer {
            0% {
                background-position: 0% 50%
            }

            50% {
                background-position: 100% 50%
            }

            100% {
                background-position: 0% 50%
            }
        }

        .header-buttons-container {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            transition: opacity .3s cubic-bezier(.215,.61,.355,1),transform .3s cubic-bezier(.215,.61,.355,1),visibility 0s .3s
        }

        #menuToggleBtn {
            display: none
        }

        @media (max-width: 450px) {
            header {
                min-height:56px;
                padding: 6px 0
            }

            .header-title {
                font-size: 1.9rem
            }

            .header-buttons {
                opacity: 0;
                visibility: hidden;
                transform: translateY(-15px) scaleY(.9);
                transform-origin: top right;
                position: absolute;
                top: calc(100% + 8px);
                right: 0;
                flex-direction: column;
                background-color: var(--color-surface);
                border: 1px solid var(--color-border);
                border-radius: var(--modal-border-radius);
                box-shadow: var(--shadow-m);
                padding: 10px;
                z-index: 999
            }

            .header-buttons.show-menu {
                display: flex;
                opacity: 1;
                visibility: visible;
                transform: translateY(0) scaleY(1);
                transition: opacity .3s cubic-bezier(.215,.61,.355,1),transform .3s cubic-bezier(.215,.61,.355,1),visibility 0s 0s
            }

            #menuToggleBtn {
                display: flex;
                background: 0 0;
                border: none;
                font-size: 1.7rem;
                cursor: pointer;
                color: var(--color-text-secondary);
                align-items: center;
                justify-content: center;
                width: 44px;
                height: 44px;
                transition: transform .25s cubic-bezier(.34,1.56,.64,1),background-color .2s ease-out,color .2s ease-out;
                border-radius: var(--button-border-radius)
            }

            #menuToggleBtn:hover {
                background-color: rgba(0,0,0,.04);
                color: var(--color-text)
            }

            #menuToggleBtn.active {
                transform: rotate(90deg);
                color: var(--fluent-blue)
            }

            .icon-btn {
                width: 100%;
                justify-content: flex-start;
                padding: 10px 15px;
                font-size: 1rem;
                height: auto
            }

            .icon-btn:not(:last-child) {
                margin-bottom: 5px
            }
        }

        .icon-btn {
            background: 0 0;
            border: none;
            font-size: 1.6rem;
            cursor: pointer;
            color: var(--color-text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            transition: transform .15s cubic-bezier(.34,1.56,.64,1),color .2s ease-out,background-color .2s ease-out;
            border-radius: var(--button-border-radius)
        }

        .icon-btn:hover {
            color: var(--color-text);
            background-color: rgba(0,0,0,.04)
        }

        .icon-btn:active {
            transform: scale(.9)
        }

        .difficulty-indicator {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: .75rem;
            padding: 6px 14px;
            color: #fff;
            border-radius: 18px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: .8px;
            box-shadow: var(--shadow-xs)
        }

        .difficulty-easy {
            background-color: var(--color-easy)
        }

        .difficulty-medium {
            background-color: var(--color-medium)
        }

        .difficulty-hard {
            background-color: var(--color-hard)
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            flex-grow: 1;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden;
            z-index: 5
        }

        .board-wrapper {
            width: 100%;
            max-width: 100vw;
            overflow-x: auto;
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 5px
        }

        .board {
            display: grid;
            gap: 6px;
            min-width: 100%;
            width: max-content;
            padding: 2px
        }

        .row {
            display: grid;
            gap: 6px;
            min-width: max-content
        }

        .tile {
            aspect-ratio: 1;
            border: 2px solid var(--color-border-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: 600;
            border-radius: var(--tile-border-radius);
            transition: transform .3s cubic-bezier(.4,0,.2,1),background-color .3s ease,border-color .3s ease,box-shadow .3s ease,color .3s ease;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: clip;
            color: var(--color-text);
            background-color: var(--color-surface);
            min-height: 48px;
            height: auto;
            min-width: 48px;
            box-shadow: var(--shadow-xs);
            position: relative;
            z-index: 1
        }
        .tile.unknown-length {
            border-style: dashed !important;
            background-color: color-mix(in srgb, var(--color-surface) 80%, var(--color-text-secondary) 20%) !important;
        }
        .tile.unknown-length::before {
            content: '?';
            font-size: 1.5em;
            color: var(--color-text-secondary);
            opacity: 0.6;
            position: absolute;
        }
        .tile.unknown-length.filled::before {
            display: none;
        }


        @media (max-width: 500px) {
            .tile {
                min-height:42px;
                font-size: 1.6rem;
                min-width: 42px;
                border-width: 1px
            }
        }

        .tile.filled {
            border-color: #9e9e9e;
            box-shadow: var(--shadow-s)
        }

        body.dark-theme .tile.filled {
            border-color: #787878
        }

        .tile.pop {
            animation: popIn .2s cubic-bezier(.175,.885,.32,1.275)
        }

        @keyframes popIn {
            0% {
                transform: scale(.75);
                opacity: .4
            }

            100% {
                transform: scale(1);
                opacity: 1
            }
        }

        .tile.flip-reveal {
            animation: flip-reveal .7s cubic-bezier(.45,.05,.55,.95) forwards
        }

        @keyframes flip-reveal {
            0% {
                transform: rotateX(0deg)
            }

            50% {
                transform: rotateX(90deg);
                background-color: var(--color-border-light)
            }

            100% {
                transform: rotateX(0deg)
            }
        }

        .tile.win-dance {
            animation: dance .8s cubic-bezier(.34,1.56,.64,1) both
        }

        @keyframes dance {
            0%,100% {
                transform: translateY(0) scale(1)
            }

            20% {
                transform: translateY(-12px) scale(1.12) rotate(-4deg)
            }

            40% {
                transform: translateY(6px) scale(.93) rotate(4deg)
            }

            60% {
                transform: translateY(-7px) scale(1.06) rotate(-2.5deg)
            }

            80% {
                transform: translateY(3px) scale(.97) rotate(1.5deg)
            }
        }

        .correct {
            background-color: var(--color-correct)!important;
            color: var(--color-key-feedback-text)!important;
            border-color: var(--color-correct)!important;
            box-shadow: none!important
        }

        .present {
            background-color: var(--color-present)!important;
            color: var(--color-key-feedback-text)!important;
            border-color: var(--color-present)!important;
            box-shadow: none!important
        }

        .absent {
            background-color: var(--color-absent)!important;
            color: var(--color-key-feedback-text)!important;
            border-color: var(--color-absent)!important;
            box-shadow: none!important
        }

        #statusIndicatorWrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            margin: 12px 0 18px;
            flex-shrink: 0;
            height: 40px
        }

        #statusIndicator {
            padding: 0 22px;
            background-color: var(--color-surface);
            color: var(--color-text-secondary);
            border-radius: 20px;
            font-size: .95rem;
            font-weight: 500;
            text-align: center;
            line-height: 40px;
            box-shadow: var(--shadow-m);
            transition-property: opacity, transform, min-width, padding, color, font-weight, background-color;
            transition-duration: .3s, .3s, .2s, .2s, .2s, .2s, .3s;
            transition-timing-function: cubic-bezier(.25,.1,.25,1), cubic-bezier(.25,.1,.25,1), ease-out, ease-out, ease-out, ease-out, ease-in-out;
            opacity: 0;
            transform: translateY(15px) scale(.9);
            white-space: nowrap;
            max-width: 85%;
            overflow: hidden;
            text-overflow: ellipsis
        }
         #statusIndicator.no-transition {
            transition-property: min-width, padding, color, font-weight, background-color !important;
            transition-duration: .2s, .2s, .2s, .2s, .3s !important;
            transition-timing-function: ease-out, ease-out, ease-out, ease-out, ease-in-out !important;
        }


        #statusIndicator.visible {
            opacity: 1;
            transform: translateY(0) scale(1)
        }

        #statusIndicator.timer-active {
            min-width: 130px;
            font-variant-numeric: tabular-nums;
            color: var(--color-text);
            font-weight: 600
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 520px;
            gap: 6px;
            padding-bottom: 10px
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 5px;
            width: 100%
        }

        .key {
            height: 54px;
            border-radius: var(--key-border-radius);
            background-color: var(--color-key-default-bg);
            font-size: 1.15rem;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            flex: 1;
            transition: background-color .15s ease-out,transform .1s cubic-bezier(.34,1.56,.64,1),box-shadow .15s ease-out,border-color .15s ease-out,color .15s ease-out;
            box-shadow: var(--shadow-xs);
            color: var(--color-key-default-text);
            border: 1px solid var(--color-key-default-border);
            position: relative;
            z-index: 1;
            overflow: hidden
        }

        .key.show-tooltip {
            overflow: visible
        }

        .key::before {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            z-index: -1;
            transition: height .3s cubic-bezier(.645,.045,.355,1);
            border-radius: inherit
        }

        .key:not(.correct):not(.present):not(.absent):hover {
            background-color: var(--color-key-default-hover-bg)
        }

        .key:not(.correct):not(.present):not(.absent):active,.key.pressed:not(.correct):not(.present):not(.absent) {
            background-color: var(--color-key-default-active-bg);
            transform: scale(.95) translateY(1px);
            box-shadow: none
        }

        .key.wide {
            flex: 1.5;
            font-size: .95rem
        }

        .key.super-wide {
            flex: 1.5;
            background-color: var(--fluent-blue);
            color: #fff;
            border-color: var(--fluent-blue-hover);
            font-weight: 600
        }

        .key.super-wide:not(.correct):not(.present):not(.absent):hover {
            background-color: var(--fluent-blue-hover)
        }

        .key.super-wide:not(.correct):not(.present):not(.absent):active {
            background-color: var(--fluent-blue-active)
        }

        .key.correct,.key.present,.key.absent {
            background-color: transparent!important;
            color: var(--color-key-feedback-text)!important;
            font-weight: 600
        }

        .key.correct {
            border-color: var(--color-correct)!important;
            animation: keyGreenPulse .4s cubic-bezier(.175,.885,.32,1.275)
        }

        .key.present {
            border-color: var(--color-present)!important
        }

        .key.absent {
            border-color: var(--color-absent)!important;
            opacity: .9
        }

        .key.correct::before {
            background-color: var(--color-correct);
            height: 100%
        }

        .key.present::before {
            background-color: var(--color-present);
            height: 100%
        }

        .key.absent::before {
            background-color: var(--color-absent);
            height: 100%
        }

        @keyframes keyGreenPulse {
            0%,100% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.08) translateY(-1px)
            }
        }

        .key.disabled-permanently {
            opacity: .45!important;
            pointer-events: none!important;
            background-color: #ced4da!important;
            color: #adb5bd!important;
            border-color: #adb5bd!important
        }

        body.dark-theme .key.disabled-permanently {
            background-color: #4a4e54!important;
            color: #72767d!important;
            border-color: #72767d!important
        }

        .key.disabled-permanently::before {
            display: none
        }

        .key.disabled-view-mode, .keyboard.disabled-input .key:not(.disabled-permanently) {
            opacity: .55!important;
            pointer-events: none!important
        }
        
        .keyboard.true-random-keys .key:not(.super-wide):not(.wide) {
            order: var(--random-order, 0);
        }


        .key-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(6px) scale(.9);
            background-color: var(--color-text);
            color: var(--color-surface);
            padding: 7px 12px;
            border-radius: var(--button-border-radius);
            font-size: .85rem;
            font-weight: 500;
            white-space: nowrap;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity .2s ease-out,transform .2s ease-out,visibility 0s .2s,background-color .3s ease-in-out,color .3s ease-in-out;
            box-shadow: var(--shadow-m);
            pointer-events: none
        }

        .key.operator-key.show-tooltip .key-tooltip,.key.operator-key:hover .key-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0) scale(1);
            transition: opacity .2s ease-out,transform .2s cubic-bezier(.175,.885,.32,1.275),visibility 0s 0s,background-color .3s ease-in-out,color .3s ease-in-out
        }

        .message {
            position: fixed;
            top: 12%;
            left: 50%;
            transform: translateX(-50%) translateY(-30px) scale(.9);
            background-color: rgba(25,25,25,.95);
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            color: #fff;
            padding: 16px 28px;
            border-radius: var(--modal-border-radius);
            z-index: 1001;
            opacity: 0;
            font-weight: 500;
            box-shadow: var(--shadow-l);
            visibility: hidden;
            transition: opacity .3s cubic-bezier(.215,.61,.355,1),transform .3s cubic-bezier(.215,.61,.355,1),visibility 0s .3s;
            width: auto;
            max-width: 88vw;
            box-sizing: border-box;
            text-align: center;
            white-space: normal;
            word-break: break-word;
            font-size: 1.05rem
        }

        .message.show-message {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            visibility: visible;
            transition: opacity .35s cubic-bezier(.175,.885,.32,1.275),transform .35s cubic-bezier(.175,.885,.32,1.275),visibility 0s 0s
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,.45);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity .3s ease-in-out,-webkit-backdrop-filter .3s ease-in-out;
            transition: opacity .3s ease-in-out,backdrop-filter .3s ease-in-out;
            transition: opacity .3s ease-in-out,backdrop-filter .3s ease-in-out,-webkit-backdrop-filter .3s ease-in-out
        }

        .modal.show {
            display: flex;
            opacity: 1
        }

        .modal-content {
            background-color: var(--color-surface);
            padding: 30px;
            border-radius: var(--modal-border-radius);
            max-width: 90%;
            width: 520px;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            opacity: 0;
            transform: translateY(30px) scale(.95);
            transition: opacity .35s cubic-bezier(.175,.885,.32,1.275),transform .35s cubic-bezier(.175,.885,.32,1.275),background-color .3s ease-in-out
        }

        .modal.show .modal-content {
            opacity: 1;
            transform: translateY(0) scale(1)
        }

        .modal h2 {
            margin-top: 0;
            margin-bottom: 22px;
            color: var(--color-text);
            font-size: 1.8rem;
            font-weight: 600;
            transition: color .3s ease-in-out
        }

        .modal p {
            color: var(--color-text-secondary);
            font-size: 1.05rem;
            line-height: 1.65;
            margin-bottom: 28px;
            transition: color .3s ease-in-out
        }

        .modal button {
            color: #fff;
            border: none;
            padding: 13px 26px;
            border-radius: var(--button-border-radius);
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 15px;
            transition: background-color .2s ease-out,transform .15s cubic-bezier(.34,1.56,.64,1),box-shadow .2s ease-out,color .2s ease-out,border-color .2s ease-out;
            min-width: 125px;
            text-transform: uppercase;
            letter-spacing: .5px
        }

        .modal button.primary-btn {
            background-color: var(--fluent-blue)
        }

        .modal button.primary-btn:hover {
            background-color: var(--fluent-blue-hover);
            box-shadow: var(--shadow-s)
        }

        .modal button.primary-btn:active {
            background-color: var(--fluent-blue-active);
            transform: scale(.96)
        }

        .modal button.secondary-btn {
            background-color: var(--color-btn-secondary-bg);
            color: var(--color-btn-secondary-text);
            border: 1px solid var(--color-btn-secondary-border)
        }

        .modal button.secondary-btn:hover {
            background-color: var(--color-btn-secondary-hover-bg);
            border-color: var(--color-btn-secondary-hover-border);
            box-shadow: var(--shadow-s)
        }

        .modal button.secondary-btn:active {
            background-color: var(--color-btn-secondary-active-bg);
            transform: scale(.96)
        }

        .modal button.danger-btn {
            background-color: var(--color-hard)!important
        }

        .modal button.danger-btn:hover {
            background-color: #c82333!important;
            box-shadow: var(--shadow-s)
        }

        .modal button.danger-btn:active {
            background-color: #bd2130!important;
            transform: scale(.96)
        }

        #gameOverTitle {
            font-size: 2.2rem;
            font-weight: 700
        }

        #gameOverMessage {
            font-size: 1.15rem;
            margin-bottom: 28px;
            color: var(--color-text-secondary)
        }

        .stats-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin: 35px 0
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center
        }

        .stat-number {
            font-size: 2.4rem;
            font-weight: 700;
            color: var(--color-text);
            transition: color .3s ease-in-out
        }

        .stat-label {
            font-size: .85rem;
            text-transform: uppercase;
            color: var(--color-text-secondary);
            letter-spacing: .8px;
            margin-top: 5px;
            transition: color .3s ease-in-out
        }

        .difficulty-selector {
            display: flex;
            justify-content: space-between;
            margin: 28px 0;
            width: 100%;
            gap: 12px
        }

        .difficulty-btn {
            padding: 14px 10px;
            border-radius: var(--button-border-radius);
            cursor: pointer;
            flex: 1;
            text-align: center;
            font-weight: 600;
            color: #fff;
            font-size: .95rem;
            border: 2px solid transparent;
            opacity: .9;
            transition: transform .2s cubic-bezier(.34,1.56,.64,1),box-shadow .25s ease-out,opacity .25s ease-out,border-color .25s ease-out,background-color .25s ease-out;
            box-shadow: var(--shadow-xs);
            line-height: 1.4
        }

        .difficulty-btn:not(.selected):hover {
            opacity: 1;
            transform: translateY(-3px);
            box-shadow: var(--shadow-m)
        }

        .difficulty-btn.selected {
            opacity: 1;
            transform: scale(1.03) translateY(-4px);
            border-width: 2px;
            font-weight: 700
        }

        .difficulty-btn.easy {
            background-color: var(--color-easy)
        }

        .difficulty-btn.medium {
            background-color: var(--color-medium)
        }

        .difficulty-btn.hard {
            background-color: var(--color-hard)
        }

        .difficulty-btn.easy.selected {
            border-color: #138496;
            box-shadow: 0 4px 12px rgba(23,162,184,.4)
        }

        .difficulty-btn.medium.selected {
            border-color: #e06200;
            box-shadow: 0 4px 12px rgba(253,126,20,.4)
        }

        .difficulty-btn.hard.selected {
            border-color: #bd2130;
            box-shadow: 0 4px 12px rgba(220,53,69,.4)
        }

        #exportImageBtn {
            background-color: var(--color-present);
            color: var(--color-text)!important;
            margin-left: 10px
        }

        #exportImageBtn:hover {
            background-color: #e0a800!important
        }

        #shareLevelBtn {
            margin-left: 10px
        }

        .flying-char-effect {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            transition: transform .35s cubic-bezier(.34,0,.66,1.5),opacity .45s ease-out,width .35s ease-out,height .35s ease-out,background-color .3s ease-in-out,color .3s ease-in-out;
            opacity: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-m)
        }

        #confettiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            overflow: hidden;
            z-index: 10000
        }

        .confetti-piece {
            position: absolute;
            pointer-events: none;
            transition-property: transform,top,opacity;
            transition-timing-function: cubic-bezier(.1,.5,.3,1),cubic-bezier(.1,.25,.3,1),ease-in;
            will-change: transform,top,opacity
        }

        .invalid-shake {
            animation: shake .5s cubic-bezier(.36,.07,.19,.97) both
        }

        @keyframes shake {
            10%,90% {
                transform: translateX(-1.5px)
            }

            20%,80% {
                transform: translateX(3px)
            }

            30%,50%,70% {
                transform: translateX(-5px)
            }

            40%,60% {
                transform: translateX(5px)
            }
        }

        textarea#levelCodeInput {
            width: 95%;
            margin-bottom: 18px;
            padding: 14px;
            border-radius: var(--button-border-radius);
            border: 1px solid var(--color-input-border);
            font-size: 1rem;
            background-color: var(--color-input-bg);
            color: var(--color-input-text);
            line-height: 1.5;
            transition: background-color .3s ease-in-out,color .3s ease-in-out,border-color .3s ease-in-out
        }

        textarea#levelCodeInput:focus {
            border-color: var(--color-input-focus-border);
            box-shadow: 0 0 0 3px var(--color-input-focus-shadow);
            outline: none
        }

        .tile.tile-new-game-appear {
            opacity: 0;
            transform: scale(.5) translateY(15px);
            animation: tileNewGameAppearAnimation .4s cubic-bezier(.175,.885,.32,1.275) forwards
        }

        @keyframes tileNewGameAppearAnimation {
            to {
                opacity: 1;
                transform: scale(1) translateY(0)
            }
        }

        .tile.tile-cleared-animation {
            animation: tileClearPop .35s cubic-bezier(.6,-.28,.735,.045) forwards
        }

        @keyframes tileClearPop {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1
            }

            30% {
                transform: scale(1.1) rotate(-4deg);
                opacity: .8
            }

            100% {
                transform: scale(.25) rotate(18deg);
                opacity: 0
            }
        }

        #historyListContainer {
            max-height: 60vh;
            overflow-y: auto;
            margin-bottom: 22px;
            padding-right: 12px;
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) var(--color-background);
            transition: scrollbar-color .3s ease-in-out
        }

        #historyListContainer::-webkit-scrollbar {
            width: 8px
        }

        #historyListContainer::-webkit-scrollbar-track {
            background: var(--color-background);
            border-radius: 4px;
            transition: background-color .3s ease-in-out
        }

        #historyListContainer::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 4px;
            border: 2px solid var(--color-background);
            transition: background-color .3s ease-in-out,border-color .3s ease-in-out
        }

        .history-item {
            background-color: var(--color-background);
            border: 1px solid var(--color-border-light);
            border-radius: var(--button-border-radius);
            padding: 18px;
            margin-bottom: 14px;
            text-align: left;
            box-shadow: var(--shadow-s);
            transition: box-shadow .25s ease-out,transform .25s ease-out,background-color .3s ease-in-out,border-color .3s ease-in-out
        }

        .history-item:hover {
            box-shadow: var(--shadow-m);
            transform: translateY(-2px) scale(1.005)
        }

        .history-item-preview {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px
        }

        .history-equation {
            font-weight: 600;
            font-size: 1.15rem;
            color: var(--color-text);
            flex-grow: 1;
            margin-right: 12px;
            word-break: break-all;
            transition: color .3s ease-in-out
        }

        .history-status {
            font-size: .85rem;
            font-weight: 700;
            padding: 5px 10px;
            border-radius: var(--button-border-radius);
            color: #fff;
            text-transform: uppercase;
            letter-spacing: .5px
        }

        .history-status.won {
            background-color: var(--color-correct)
        }

        .history-status.lost,.history-status.surrendered, .history-status.abandoned, .history-status.lost_sudden_death {
            background-color: var(--color-hard)
        }


        .history-item-details {
            font-size: .9rem;
            color: var(--color-text-secondary);
            margin-bottom: 14px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px 12px;
            transition: color .3s ease-in-out
        }

        .history-item-details span {
            white-space: nowrap
        }

        .history-item-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end
        }

        .history-item-actions button {
            padding: 9px 14px;
            font-size: .9rem;
            min-width: auto;
            margin-top: 0
        }

        #noHistoryMessage {
            color: var(--color-text-secondary);
            padding: 25px;
            font-size: 1.05rem;
            transition: color .3s ease-in-out
        }
        
        .debug-option-group {
            border: 1px solid var(--color-divider);
            border-radius: var(--button-border-radius);
            padding: 15px;
            margin-bottom: 20px;
            background-color: var(--color-background);
            box-shadow: var(--shadow-xs);
        }
        .debug-option-group h4 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1rem;
            color: var(--color-text);
            border-bottom: 1px solid var(--color-border-light);
            padding-bottom: 8px;
        }
        .debug-button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: space-between; 
        }
        .debug-button-row button.small-btn {
            flex-grow: 1; 
            flex-basis: calc(33.333% - 10px); 
            min-width: 100px; 
            padding: 10px 5px;
            font-size: 0.85rem;
        }
         .debug-button-row button.small-btn.two-per-row {
            flex-basis: calc(50% - 5px); 
        }

        button.full-width-btn {
            width: 100%;
            margin-top: 8px;
        }
        .input-with-button {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .input-with-button input[type="number"], .input-with-button input[type="text"] {
            flex-grow: 1;
            width: auto; 
        }
        .input-with-button button.small-btn {
            padding: 10px 15px; 
            font-size: 0.85rem;
            margin-top: 0;
            flex-shrink: 0; 
        }
        #debugModal .modal-content {
            max-height: 85vh; 
        }


        .debug-option {
            margin-bottom: 18px;
            text-align: left;
        }
        .debug-option label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 0.95rem;
        }
        .debug-option input[type="number"], .debug-option textarea, .debug-option input[type="text"] {
            width: 100%; 
            padding: 10px; 
            border-radius: var(--button-border-radius);
            border: 1px solid var(--color-input-border);
            font-size: 0.9rem; 
            background-color: var(--color-input-bg);
            color: var(--color-input-text);
            line-height: 1.4;
            transition: background-color .3s ease-in-out,color .3s ease-in-out,border-color .3s ease-in-out;
            box-sizing: border-box; 
        }
        .debug-option input[type="number"]:focus, .debug-option textarea:focus, .debug-option input[type="text"]:focus {
            border-color: var(--color-input-focus-border);
            box-shadow: 0 0 0 3px var(--color-input-focus-shadow);
            outline: none;
        }
        .debug-option input[type="checkbox"], .debug-option input[type="color"] {
            vertical-align: middle;
            margin-right: 8px;
            width: auto;
            height: auto;
            padding: 0;
        }
         .debug-option input[type="color"] {
            min-height: 30px; 
         }
        .debug-option .checkbox-label {
            display: inline;
            font-weight: normal;
            margin-bottom: 0;
        }

        #debugModalTitle {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--color-divider);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(var(--current-animation-angle,120deg),var(--title-grad-debug-1),var(--title-grad-debug-2),var(--title-grad-debug-3),var(--title-grad-debug-2),var(--title-grad-debug-1));
            background-size: 300% 300%;
            animation: titleShimmer 6s cubic-bezier(.65,.05,.36,1) infinite alternate;
        }
        #debugModal .modal-button-container {
            margin-top: 25px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid var(--color-divider);
            padding-top: 20px;
        }
      #confirmNukeModal {
            z-index: 1002;
        }

    </style>
</head>
<body>
    <canvas id="dynamicBackgroundCanvas"></canvas>
    <header>
        <div id="difficultyDisplay" class="difficulty-indicator difficulty-medium">中等</div>
        <div class="header-title state-idle" id="mainHeaderTitle">SUMZLE</div>
        <div class="header-buttons-container">
            <button id="menuToggleBtn">☰</button>
            <div class="header-buttons" id="headerButtonsGroup">
                <button class="icon-btn" id="themeToggleBtn" title="切换主题">☀️</button>
                <button class="icon-btn" id="loadLevelBtn" title="载入关卡">🔗</button>
                <button class="icon-btn" id="historyBtn" title="游戏历史">📜</button>
                <button class="icon-btn" id="statsBtn" title="统计">📊</button>
                <button class="icon-btn" id="settingsBtn" title="设置">⚙️</button>
                <button class="icon-btn" id="restartBtn" title="重新开始/投降">🔄</button>
            </div>
        </div>
    </header>
    <div id="confettiOverlay"></div>
    <div class="game-container" id="gameContainer">
        <div class="board-wrapper">
            <div class="board" id="board"></div>
        </div>
        <div id="statusIndicatorWrapper">
            <div id="statusIndicator" class="status-indicator">准备开始</div>
        </div>
        <div class="keyboard" id="keyboard"></div>
    </div>
    <div class="message" id="message"></div>
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverMessage"></p>
            <div class="stats-container">
                <div class="stat">
                    <div class="stat-number" id="gamesPlayed">0</div>
                    <div class="stat-label">已玩</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="gamesWon">0</div>
                    <div class="stat-label">获胜</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="currentStreak">0</div>
                    <div class="stat-label">连胜</div>
                </div>
            </div>
            <button id="newGameBtn" class="primary-btn">开始新游戏</button>
            <button id="exportImageBtn" class="secondary-btn" style="display:none;">导出图片</button>
            <button id="shareLevelBtn" class="secondary-btn">分享关卡</button>
        </div>
    </div>
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>设置</h2>
            <h3>难度选择</h3>
            <div class="difficulty-selector">
                <div class="difficulty-btn easy" data-difficulty="easy">
                    简单<br>(8次)
                </div>
                <div class="difficulty-btn medium selected" data-difficulty="medium">
                    中等<br>(6次)
                </div>
                <div class="difficulty-btn hard" data-difficulty="hard">
                    困难<br>(4次)
                </div>
            </div>
            <button id="closeSettingsBtn" class="primary-btn">确定</button>
        </div>
    </div>
    <div class="modal" id="statsModal">
        <div class="modal-content">
            <h2>游戏统计</h2>
            <div style="width: 100%; max-width: 450px; margin: 20px auto;">
                <canvas id="statsChart"></canvas>
            </div>
            <button id="clearStatsBtn" class="danger-btn">清空统计数据</button>
            <button id="closeStatsBtn" class="secondary-btn" style="margin-top: 10px;">关闭</button>
        </div>
    </div>
    <div class="modal" id="loadLevelModal">
        <div class="modal-content">
            <h2>载入分享关卡</h2>
            <textarea id="levelCodeInput" placeholder="在此处粘贴关卡代码..." rows="3"></textarea>
            <button id="submitLoadLevelBtn" class="primary-btn">载入</button>
            <button id="closeLoadLevelModalBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="surrenderModal">
        <div class="modal-content">
            <h2>放弃挑战？</h2>
            <p>确定要放弃当前的游戏吗？这将会被记录为一次失败。</p>
            <button id="confirmSurrenderBtn" class="danger-btn">确认放弃</button>
            <button id="cancelSurrenderBtn" class="secondary-btn" style="margin-left: 10px;">继续挑战</button>
        </div>
    </div>
    <div class="modal" id="confirmClearStatsModal">
        <div class="modal-content">
            <h2>确认操作</h2>
            <p>确定要清空所有统计数据吗？此操作无法撤销。</p>
            <button id="executeClearStatsBtn" class="danger-btn">确认清空</button>
            <button id="cancelClearStatsBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <h2>游戏历史</h2>
            <div id="historyListContainer"></div>
            <p id="noHistoryMessage" style="display:none;">暂无历史记录。</p>
            <button id="clearHistoryBtn" class="danger-btn" style="margin-right:10px; display:none;">清空历史</button>
            <button id="closeHistoryModalBtn" class="secondary-btn">关闭</button>
        </div>
    </div>
    <div class="modal" id="confirmClearHistoryModal">
        <div class="modal-content">
            <h2>确认操作</h2>
            <p>确定要清空所有游戏历史记录吗？此操作无法撤销。</p>
            <button id="executeClearHistoryBtn" class="danger-btn">确认清空</button>
            <button id="cancelClearHistoryBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="confirmNukeModal">
        <div class="modal-content">
            <h2 id="confirmNukeTitle">清除数据</h2>
            <p id="confirmNukeMessage" style="font-weight: bold;">确定要清除所有本地存储数据吗？包括统计、历史、设置等。此操作将重置游戏到初始状态且无法撤销！</p>
            <button id="executeNukeBtn" class="danger-btn">确认核爆本地数据</button>
            <button id="cancelNukeBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>

    <div class="modal" id="debugModal">
        <div class="modal-content">
            <h2 id="debugModalTitle">QUARK 调试面板</h2>
            <div class="debug-option-group">
                <h4>表达式与生成控制</h4>
                <div class="debug-option">
                    <label for="debugCustomExpr">指定下次游戏表达式:</label>
                    <textarea id="debugCustomExpr" rows="2" placeholder="例如, 1+1=2"></textarea>
                </div>
                <div class="debug-option">
                    <label for="debugLockLength">固定表达式长度 (0=自动):</label>
                    <input type="number" id="debugLockLength" min="0" value="0">
                </div>
                <div class="debug-option">
                    <label for="debugMaxGenAttempts">表达式生成尝试次数上限 (0=自动):</label>
                    <input type="number" id="debugMaxGenAttempts" min="0" value="0">
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugDisableMax">
                    <label for="debugDisableMax" class="checkbox-label">移除最大长度限制 (默认15)</label>
                </div>
                 <div class="debug-option debug-button-row">
                    <button id="debugGenerateExprBtn" class="secondary-btn small-btn">随机生成表达式</button>
                    <button id="debugLogTargetBtn" class="secondary-btn small-btn">记录目标至控制台</button>
                 </div>
                <textarea id="debugGeneratedExprDisplay" rows="2" readonly placeholder="生成的表达式会在此显示..."></textarea>
            </div>
            
             <div class="debug-option-group">
                <h4>实验性玩法调整</h4>
                 <div class="debug-option">
                    <input type="checkbox" id="debugUnknownLengthToggle">
                    <label for="debugUnknownLengthToggle" class="checkbox-label">目标长度未知模式</label>
                </div>
                 <div class="debug-option">
                    <input type="checkbox" id="debugOneTryModeToggle">
                    <label for="debugOneTryModeToggle" class="checkbox-label">极限挑战模式 (单行决胜)</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugMirrorInputToggle">
                    <label for="debugMirrorInputToggle" class="checkbox-label">镜像键盘输入模式</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugRandomKeyboardLayoutToggle">
                    <label for="debugRandomKeyboardLayoutToggle" class="checkbox-label">随机化键盘按键布局</label>
                </div>
                 <div class="debug-option">
                    <label for="debugMisleadingFeedbackRate">误导性反馈概率 (%):</label>
                    <input type="number" id="debugMisleadingFeedbackRate" min="0" max="100" value="0">
                </div>
                 <div class="debug-option">
                    <input type="checkbox" id="debugSuddenDeathTimerToggle">
                    <label for="debugSuddenDeathTimerToggle" class="checkbox-label">计时挑战模式 (30秒)</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugVanishingInkToggle">
                    <label for="debugVanishingInkToggle" class="checkbox-label">隐形墨水模式 (字符渐隐)</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugGrayKeysUnclickableToggle">
                    <label for="debugGrayKeysUnclickableToggle" class="checkbox-label">禁用已排除字符按键</label>
                </div>
            </div>

            <div class="debug-option-group">
                <h4>当前游戏状态控制</h4>
                <div class="debug-option">
                    <label for="debugCurrentTargetDisplay">当前游戏目标表达式:</label>
                    <textarea id="debugCurrentTargetDisplay" rows="1" readonly></textarea>
                </div>
                <div class="debug-option debug-button-row">
                    <button id="debugForceWinBtn" class="secondary-btn small-btn two-per-row">强制判定为胜利</button>
                    <button id="debugForceLoseBtn" class="secondary-btn small-btn two-per-row">强制判定为失败</button>
                </div>
                <div class="debug-option debug-button-row">
                    <button id="debugTriggerShakeBtn" class="secondary-btn small-btn two-per-row">测试无效输入抖动效果</button>
                    <button id="debugClearInputRowBtn" class="secondary-btn small-btn two-per-row">清除当前行已输入内容</button>
                </div>
            </div>

            <div class="debug-option-group">
                <h4>界面与效果工具</h4>
                 <div class="debug-option debug-button-row">
                    <button id="debugSoundKeypress" class="secondary-btn small-btn">测试按键音效</button>
                    <button id="debugSoundWin" class="secondary-btn small-btn">测试胜利音效</button>
                    <button id="debugSoundFail" class="secondary-btn small-btn">测试失败音效</button>
                </div>
                <div class="debug-option debug-button-row">
                    <button id="debugConfettiBtn" class="secondary-btn small-btn two-per-row">测试胜利纸屑效果</button>
                    <button id="debugThemeCycleBtn" class="secondary-btn small-btn two-per-row">循环切换界面主题</button>
                </div>
                 <div class="debug-option">
                    <label for="debugBgParticles">背景粒子效果数量 (0=自动):</label>
                    <div class="input-with-button">
                        <input type="number" id="debugBgParticles" min="0" value="0">
                        <button id="debugApplyBgParticlesBtn" class="secondary-btn small-btn">设置</button>
                    </div>
                </div>
                 <div class="debug-option">
                    <input type="checkbox" id="debugPsychedelicBgToggle">
                    <label for="debugPsychedelicBgToggle" class="checkbox-label">启用动态迷幻背景效果</label>
                </div>
            </div>
            
            <div class="debug-option-group">
                <h4>高级与危险操作区</h4>
                <div class="debug-option">
                    <label for="debugStressTestRuns">表达式生成器压力测试 (轮次):</label>
                    <div class="input-with-button">
                        <input type="number" id="debugStressTestRuns" min="1" value="100">
                        <button id="debugRunStressTestBtn" class="secondary-btn small-btn">执行测试</button>
                    </div>
                    <textarea id="debugStressTestResults" rows="3" readonly style="margin-top:8px;" placeholder="压力测试结果将在此显示..."></textarea>
                </div>
                <div class="debug-option">
                     <button id="debugNukeStorageBtn" class="danger-btn full-width-btn">☢️ 清除所有本地存储并重载</button>
                </div>
            </div>

            <p id="debugHint" style="font-size:0.85rem; color: var(--color-text-secondary); margin-top:15px; margin-bottom:20px;">部分设置调整将在开始新游戏或重玩当前关卡时应用。自定义表达式仅在下次游戏生效一次。</p>
            
            <div class="modal-button-container">
                <button id="applyDebugSettingsBtn" class="primary-btn">应用设置并关闭</button>
                <button id="closeDebugModalBtn" class="secondary-btn">直接关闭</button>
            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', ()=>{
            const difficultySetting = {
                easy: {
                    attempts: 8,
                    name: "简单",
                    class: "difficulty-easy",
                    color: "rgba(23,162,184,1)"
                },
                medium: {
                    attempts: 6,
                    name: "中等",
                    class: "difficulty-medium",
                    color: "rgba(253,126,20,1)"
                },
                hard: {
                    attempts: 4,
                    name: "困难",
                    class: "difficulty-hard",
                    color: "rgba(220,53,69,1)"
                }
            };
            let currentDifficulty = "medium"
              , ROWS = difficultySetting[currentDifficulty].attempts;
            const DEFAULT_MAX_EQUATION_LENGTH = 15
              , MIN_EQUATION_LENGTH = 3;
            let gameActive = true
              , currentRow = 0
              , currentCol = 0
              , guessedEquation = []
              , targetEquation = ''
              , COLS = 0
              , isCustomLevel = false;
            let stats = {
                total: {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    currentStreak: 0,
                    bestStreak: 0
                },
                byDifficulty: {
                    easy: {
                        gamesPlayed: 0,
                        gamesWon: 0
                    },
                    medium: {
                        gamesPlayed: 0,
                        gamesWon: 0
                    },
                    hard: {
                        gamesPlayed: 0,
                        gamesWon: 0
                    }
                }
            };
            const initialStats = JSON.parse(JSON.stringify(stats));
            let statsChartInstance = null;
            const XOR_KEY = "SUMZLECRYPTLVL"
              , SHARE_SEPARATOR = "::DIFEQ::";
            let activeTooltipKey = null
              , activeTooltipTimeout = null;
            const keyTooltips = {
                '+': '加法',
                '-': '减法',
                '*': '乘法',
                '/': '除法',
                '%': '取模',
                '^': '乘方',
                '>': '大于',
                '!': '阶乘',
                'A': '排列 (mAn)',
                '(': '左括号',
                ')': '右括号',
                '[': '取整数部分 ([n])',
                ']': '取整结束',
                '=': '等于'
            };
            const statusIndicator = document.getElementById('statusIndicator');
            const headerTitleElement = document.getElementById('mainHeaderTitle');
            let gameStartTime = 0
              , gameTimerInterval = null
              , elapsedSeconds = 0
              , guessedEquationsHistory = []
              , isViewingHistoryState = false
              , viewingHistoryItem = null;
            const restartBtn = document.getElementById('restartBtn');
            let bgCanvas, bgCtx, stars = [], dayParticles = [], animationFrameId_bg, currentBgMode = 'dark', currentTheme = 'light';
            const STAR_COLORS = ["#FFFFFF", "#FFFFAA", "#FFEEFF", "#DDEEFF"];
            const sounds = {
                keyPress: new Audio('sounds/keypress.wav'),
                success: new Audio('sounds/success.wav'),
                failure: new Audio('sounds/failure.wav')
            };
            sounds.keyPress.volume = .3;
            sounds.success.volume = .5;
            sounds.failure.volume = .5;
            function playSound(soundName) {
                if (sounds[soundName]) {
                    sounds[soundName].currentTime = 0;
                    sounds[soundName].play().catch(e=>{}
                    );
                }
            }
            const idleGradients = [{
                c1: '#4facfe',
                c2: '#00f2fe',
                c3: '#43e97b'
            }, {
                c1: '#ff9a9e',
                c2: '#fecfef',
                c3: '#ffdde1'
            }, {
                c1: '#a18cd1',
                c2: '#fbc2eb',
                c3: '#8fd3f4'
            }, {
                c1: '#f6d365',
                c2: '#fda085',
                c3: '#ffc3a0'
            }, {
                c1: '#667eea',
                c2: '#764ba2',
                c3: '#6a11cb'
            }];
            let currentIdleGradientIndex = 0;
            let isClearingRowWithAnimation = false;
            
            let liveStatusUpdateInterval = null;
            const LIVE_STATUS_UPDATE_INTERVAL_MS = 100;
            let statusIndicatorAnimationTimeout = null;
            let isStatusIndicatorAnimating = false;
            const ABANDONED_STATUS = 'ABANDONED';

            let sumzleEasterEggActivated = false;
            let quarkModeActive = false;
            let sumzleTitleClickCount = 0;
            const SUMZLE_CLICK_THRESHOLD = 7;
            const ORIGINAL_TITLE_TEXT = "SUMZLE";
            const QUARK_TITLE_TEXT = "QUARK";
            let titleFallAnimation = {
                active: false,
                element: null,
                y: 0,
                vy: 0,
                initialVyForQuark: -20,
                gravity: 0.8,
                targetY: 0,
                type: '',
                onComplete: null,
                originalComputedTransition: null,
                originalComputedTop: '0px'
            };
            
            let debugSettings = {
                lockedLength: 0,
                disableMaxLength: false,
                customExpression: "",
                useCustomExpressionForNextGame: false,
                maxGenAttempts: 0,
                customBgParticleCount: 0,
                psychedelicBgActive: false,
                originalTitleColors: {c1: '', c2: '', c3: ''},
                unknownLengthMode: false,
                oneTryMode: false,
                mirrorInputMode: false,
                randomKeyboardLayout: false,
                misleadingFeedbackRate: 0,
                suddenDeathTimer: false,
                vanishingInkMode: false,
                suddenDeathIntervalId: null,
                grayKeysUnclickable: false,
            };
            let quarkDebugClickCount = 0;
            const QUARK_DEBUG_CLICK_THRESHOLD = 7;
             
            const mirrorMap = {
                '1':'0', '2':'9', '3':'8', '4':'7', '5':'6', '6':'5', '7':'4', '8':'3', '9':'2', '0':'1',
                '(' : ')', ')' : '(', '[' : ']', ']' : '[','+':'-','-':'+','*':'/','/':'*','×':'÷','÷':'×'
            };


            function setupTitleSpans(text) {
                headerTitleElement.innerHTML = '';
                text.split('').forEach(char=>{
                    const span = document.createElement('span');
                    span.className = 'title-char';
                    span.textContent = char;
                    headerTitleElement.appendChild(span);
                }
                );
            }

            function setHeaderTitleState(state) {
                const stateClasses = ['state-idle', 'state-win', 'state-lose', 'state-custom', 'state-history', 'state-debug', 'state-quark'];
                stateClasses.forEach(cls=>{
                    if (cls === `state-${state}`) {
                        if (!headerTitleElement.classList.contains(cls))
                            headerTitleElement.classList.add(cls);
                    } else
                        headerTitleElement.classList.remove(cls);
                }
                );
                let c1, c2, c3, animationAngle = '120deg', newAnimationDuration = '10s', filterStyle = 'none';
                const rootStyle = getComputedStyle(document.documentElement);
                
                if (debugSettings.originalTitleColors.c1 === '') { 
                    debugSettings.originalTitleColors.c1 = rootStyle.getPropertyValue('--current-title-color-1').trim();
                    debugSettings.originalTitleColors.c2 = rootStyle.getPropertyValue('--current-title-color-2').trim();
                    debugSettings.originalTitleColors.c3 = rootStyle.getPropertyValue('--current-title-color-3').trim();
                }


                switch (state) {
                case 'win':
                    c1 = rootStyle.getPropertyValue('--title-grad-win-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-win-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-win-3').trim();
                    animationAngle = '75deg';
                    newAnimationDuration = '4s';
                    filterStyle = `drop-shadow(0 0 8px ${c2})`;
                    break;
                case 'lose':
                    c1 = rootStyle.getPropertyValue('--title-grad-lose-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-lose-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-lose-3').trim();
                    animationAngle = '100deg';
                    newAnimationDuration = '12s';
                    filterStyle = `saturate(.6) brightness(.85) drop-shadow(0 0 5px rgba(0,0,0,.3))`;
                    break;
                case 'custom':
                    c1 = rootStyle.getPropertyValue('--title-grad-custom-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-custom-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-custom-3').trim();
                    animationAngle = '80deg';
                    newAnimationDuration = '7s';
                    filterStyle = `drop-shadow(0 0 6px ${c2})`;
                    break;
                case 'history':
                    c1 = rootStyle.getPropertyValue('--title-grad-history-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-history-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-history-3').trim();
                    animationAngle = '90deg';
                    newAnimationDuration = '9s';
                    filterStyle = `saturate(.8) drop-shadow(0 0 4px ${c2})`;
                    break;
                case 'debug':
                    c1 = rootStyle.getPropertyValue('--title-grad-debug-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-debug-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-debug-3').trim();
                    animationAngle = '60deg';
                    newAnimationDuration = '5s';
                    filterStyle = `drop-shadow(0 0 10px ${c2}) contrast(1.2)`;
                    document.getElementById('debugModalTitle').style.setProperty('--current-title-color-1', c1);
                    document.getElementById('debugModalTitle').style.setProperty('--current-title-color-2', c2);
                    document.getElementById('debugModalTitle').style.setProperty('--current-title-color-3', c3);
                    document.getElementById('debugModalTitle').style.setProperty('--current-animation-angle', animationAngle);
                    break;
                case 'quark':
                    c1 = rootStyle.getPropertyValue('--title-grad-quark-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-quark-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-quark-3').trim();
                    animationAngle = '45deg';
                    newAnimationDuration = '6s';
                    filterStyle = `drop-shadow(0 0 12px ${c3}) brightness(1.1)`;
                    break;
                default: 
                    const grad = idleGradients[currentIdleGradientIndex];
                    c1 = grad.c1;
                    c2 = grad.c2;
                    c3 = grad.c3;
                    if (state === 'idle')
                        currentIdleGradientIndex = (currentIdleGradientIndex + 1) % idleGradients.length;
                    animationAngle = '120deg';
                    newAnimationDuration = '10s';
                    filterStyle = 'none';
                    break;
                }
                headerTitleElement.style.setProperty('--current-title-color-1', c1);
                headerTitleElement.style.setProperty('--current-title-color-2', c2);
                headerTitleElement.style.setProperty('--current-title-color-3', c3);
                headerTitleElement.style.setProperty('--current-animation-angle', animationAngle);
                headerTitleElement.style.animationDuration = newAnimationDuration;
                headerTitleElement.style.filter = filterStyle;
            }
            function isEffectivelyDarkMode() {
                return currentTheme === 'dark';
            }
            function applyTheme(theme) {
                currentTheme = theme;
                const themeToggleBtn = document.getElementById('themeToggleBtn');
                const activeStateClass = Array.from(headerTitleElement.classList).find(c=>c.startsWith('state-'));
                const currentTitleState = activeStateClass ? activeStateClass.replace('state-', '') : 'idle';
                if (theme === 'dark') {
                    document.body.classList.add('dark-theme');
                    document.body.style.backgroundColor = 'var(--color-background)';
                    if (themeToggleBtn)
                        themeToggleBtn.innerHTML = '🌙';
                } else {
                    document.body.classList.remove('dark-theme');
                    document.body.style.backgroundColor = 'var(--color-background)';
                    if (themeToggleBtn)
                        themeToggleBtn.innerHTML = '☀️';
                }
                setHeaderTitleState(currentTitleState);
                updateBackgroundStyle();
                if (statsChartInstance || document.getElementById('statsModal').classList.contains('show'))
                    updateStatsDisplay();
            }
            function toggleTheme() {
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                localStorage.setItem('sumzleTheme', newTheme);
                applyTheme(newTheme);
            }
            const savedTheme = localStorage.getItem('sumzleTheme');
            if (savedTheme)
                applyTheme(savedTheme);
            else
                applyTheme('light');
            document.getElementById('themeToggleBtn').addEventListener('click', toggleTheme);
            
            function updateBackgroundStyle() {
                const darkMode = isEffectivelyDarkMode();
                if (darkMode) {
                    if (currentBgMode !== 'night' || stars.length === 0 || debugSettings.customBgParticleCount > 0 || debugSettings.psychedelicBgActive) {
                        currentBgMode = 'night';
                        dayParticles = [];
                        populateStars();
                    }
                } else {
                    if (currentBgMode !== 'day' || dayParticles.length === 0 || debugSettings.customBgParticleCount > 0 || debugSettings.psychedelicBgActive) {
                        currentBgMode = 'day';
                        stars = [];
                        populateDayParticles();
                    }
                }
                if (!animationFrameId_bg && (stars.length > 0 || dayParticles.length > 0))
                    animateBackground();
                else if (stars.length === 0 && dayParticles.length === 0 && animationFrameId_bg) {
                    cancelAnimationFrame(animationFrameId_bg);
                    animationFrameId_bg = null;
                    if (bgCtx && bgCanvas)
                        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                }
            }

            function initBackground() {
                bgCanvas = document.getElementById('dynamicBackgroundCanvas');
                if (!bgCanvas)
                    return;
                bgCtx = bgCanvas.getContext('2d');
                resizeBackgroundCanvas();
                window.addEventListener('resize', resizeBackgroundCanvas);
                updateBackgroundStyle();
            }
            function resizeBackgroundCanvas() {
                if (!bgCanvas || !bgCtx)
                    return;
                bgCanvas.width = window.innerWidth;
                bgCanvas.height = window.innerHeight;
                if(debugSettings.psychedelicBgActive || debugSettings.customBgParticleCount > 0) { 
                    updateBackgroundStyle();
                }
            }
            function Particle(x, y, radius, color, dx, dy, opacity) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.dx = dx;
                this.dy = dy;
                this.opacity = opacity;
            }
            Particle.prototype.draw = function() {
                if (!bgCtx)
                    return;
                bgCtx.beginPath();
                bgCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                bgCtx.save();
                bgCtx.globalAlpha = this.opacity;
                bgCtx.fillStyle = this.color;
                bgCtx.fill();
                bgCtx.restore();
                bgCtx.closePath();
            }
            Particle.prototype.update = function(isStar=false) {
                if (!bgCanvas)
                    return;
                if (isStar) {
                    this.y += this.dy;
                    if (Math.random() < .015 && !debugSettings.psychedelicBgActive) 
                        this.opacity = Math.random() * .6 + .2;
                    if (this.y - this.radius > bgCanvas.height) {
                        this.y = 0 - this.radius - Math.random() * 25;
                        this.x = Math.random() * bgCanvas.width;
                        this.opacity = debugSettings.psychedelicBgActive ? 1 : (Math.random() * .5 + .5);
                    }
                } else {
                    this.x += this.dx;
                    this.y += this.dy;
                    if (this.x - this.radius > bgCanvas.width || this.x + this.radius < 0 || this.y - this.radius > bgCanvas.height || this.y + this.radius < 0) {
                        this.y = bgCanvas.height + this.radius + Math.random() * 50;
                        this.x = Math.random() * bgCanvas.width;
                        this.dx = (Math.random() - .5) * (debugSettings.psychedelicBgActive ? 2 : .6);
                        this.dy = -(Math.random() * (debugSettings.psychedelicBgActive ? 1 : .3) + .1);
                        this.opacity = debugSettings.psychedelicBgActive ? (Math.random()*0.4 + 0.6) : (Math.random() * .3 + .2);
                    }
                }
                this.draw();
            }
            function populateStars() {
                if (!bgCanvas || !bgCtx)
                    return;
                stars = [];
                let numStars, baseSpeed;
                const difficultyToUse = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.difficulty : currentDifficulty;
                
                if (debugSettings.psychedelicBgActive) {
                    numStars = 150; baseSpeed = 1.5;
                } else {
                    switch (difficultyToUse) {
                        case 'easy': numStars = 80; baseSpeed = .15; break;
                        case 'medium': numStars = 120; baseSpeed = .3; break;
                        case 'hard': numStars = 160; baseSpeed = .45; break;
                        default: numStars = 120; baseSpeed = .3;
                    }
                }


                if (debugSettings.customBgParticleCount > 0 && !debugSettings.psychedelicBgActive) {
                    numStars = debugSettings.customBgParticleCount;
                } else if (!debugSettings.psychedelicBgActive) {
                    if (isCustomLevel && !isViewingHistoryState) numStars = Math.min(numStars, 100);
                    if (isViewingHistoryState) {
                        numStars = Math.max(50, Math.floor(numStars * .6));
                        baseSpeed *= .7;
                    }
                    if (!gameActive && !isViewingHistoryState && currentBgMode === 'night') {
                        numStars = Math.floor(numStars * .8);
                        baseSpeed *= .8;
                    }
                }

                for (let i = 0; i < numStars; i++) {
                    const radius = debugSettings.psychedelicBgActive ? (Math.random() * 3 + 1) : (Math.random() * 1.3 + .4);
                    const x = Math.random() * bgCanvas.width;
                    const y = Math.random() * bgCanvas.height;
                    const color = debugSettings.psychedelicBgActive ? `hsl(${Math.random() * 360}, 100%, 70%)` : STAR_COLORS[Math.floor(Math.random() * STAR_COLORS.length)];
                    const dy = (Math.random() * .5 + .1) * baseSpeed;
                    stars.push(new Particle(x,y,radius,color,0,dy, debugSettings.psychedelicBgActive ? 1 : (Math.random() * .5 + .5)));
                }
            }
            function populateDayParticles() {
                if (!bgCanvas || !bgCtx)
                    return;
                dayParticles = [];
                let numParticles, baseColorRGB;
                const difficultyToUse = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.difficulty : currentDifficulty;
                const getColorParts = colorStr=>{
                    const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d\.]+)?\)/);
                    if (match) return { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]) };
                    return { r: 253, g: 126, b: 20 };
                };

                if (debugSettings.psychedelicBgActive) {
                    numParticles = 50;
                } else {
                     switch (difficultyToUse) {
                        case 'easy': numParticles = 35; baseColorRGB = getColorParts(difficultySetting.easy.color); break;
                        case 'medium': numParticles = 25; baseColorRGB = getColorParts(difficultySetting.medium.color); break;
                        case 'hard': numParticles = 18; baseColorRGB = getColorParts(difficultySetting.hard.color); break;
                        default: numParticles = 25; baseColorRGB = getColorParts(difficultySetting.medium.color);
                    }
                }


                if (debugSettings.customBgParticleCount > 0 && !debugSettings.psychedelicBgActive) {
                    numParticles = debugSettings.customBgParticleCount;
                } else if (!debugSettings.psychedelicBgActive) {
                    if (isCustomLevel && !isViewingHistoryState) numParticles = Math.min(numParticles, 20);
                    if (isViewingHistoryState) numParticles = Math.max(10, Math.floor(numParticles * .7));
                    if (!gameActive && !isViewingHistoryState && currentBgMode === 'day') numParticles = Math.floor(numParticles * .8);
                }

                for (let i = 0; i < numParticles; i++) {
                    const radius = debugSettings.psychedelicBgActive ? (Math.random() * 40 + 15) : (Math.random() * 25 + 10);
                    const x = Math.random() * bgCanvas.width;
                    const y = Math.random() * bgCanvas.height + radius;
                    const particleOpacity = debugSettings.psychedelicBgActive ? (Math.random() * .3 + .1) : (Math.random() * .15 + .05);
                    const color = debugSettings.psychedelicBgActive ? `hsla(${Math.random() * 360}, 100%, 60%, ${particleOpacity})` : `rgba(${baseColorRGB.r},${baseColorRGB.g},${baseColorRGB.b},${particleOpacity})`;
                    const dx = (Math.random() - .5) * (debugSettings.psychedelicBgActive ? 1.2 : .4);
                    const dy = -(Math.random() * (debugSettings.psychedelicBgActive ? 0.6 : .15) + .03);
                    dayParticles.push(new Particle(x,y,radius,color,dx,dy,1));
                }
            }
            function animateBackground() {
                if (!bgCtx || !bgCanvas) return;
                animationFrameId_bg = requestAnimationFrame(animateBackground);
                
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                

                if (currentBgMode === 'night') stars.forEach(star=>star.update(true));
                else dayParticles.forEach(particle=>particle.update(false));
            }
            initBackground();
            function displayChar(char) {
                if (char === '*')
                    return '×';
                if (char === '/')
                    return '÷';
                return char;
            }
            function encodeLevel(eq, difficulty) {
                const combined = `${difficulty}${SHARE_SEPARATOR}${eq}`;
                let xored = "";
                for (let i = 0; i < combined.length; i++)
                    xored += String.fromCharCode(combined.charCodeAt(i) ^ XOR_KEY.charCodeAt(i % XOR_KEY.length));
                try {
                    return btoa(xored);
                } catch (e) {
                    return null;
                }
            }
            function decodeLevel(encodedLevel) {
                try {
                    let xored = atob(encodedLevel)
                      , original = "";
                    for (let i = 0; i < xored.length; i++)
                        original += String.fromCharCode(xored.charCodeAt(i) ^ XOR_KEY.charCodeAt(i % XOR_KEY.length));
                    const parts = original.split(SHARE_SEPARATOR);
                    if (parts.length === 2 && difficultySetting[parts[0]])
                        return {
                            difficulty: parts[0],
                            equation: parts[1]
                        };
                    return null;
                } catch (e) {
                    return null;
                }
            }
            if (localStorage.getItem('sumzleStats')) {
                const savedStats = JSON.parse(localStorage.getItem('sumzleStats'));
                if (savedStats.byDifficulty)
                    stats = savedStats;
                else {
                    stats.total.gamesPlayed = savedStats.gamesPlayed || 0;
                    stats.total.gamesWon = savedStats.gamesWon || 0;
                    stats.total.currentStreak = savedStats.currentStreak || 0;
                    stats.total.bestStreak = savedStats.bestStreak || 0;
                }
            }
            if (localStorage.getItem('sumzleDifficulty')) {
                const savedDiff = localStorage.getItem('sumzleDifficulty');
                if (difficultySetting[savedDiff])
                    currentDifficulty = savedDiff;
                ROWS = difficultySetting[currentDifficulty].attempts;
            }
            const validChars = "0123456789+-*/%^=()![]>A";
            window.factorial = function(n) {
                n = Number(n);
                if (isNaN(n) || n < 0 || n !== Math.floor(n))
                    throw new Error("Factorial non-neg int.");
                if (n > 10)
                    throw new Error("Factorial max 10.");
                if (n === 0 || n === 1)
                    return 1;
                let result = 1;
                for (let i = 2; i <= n; i++)
                    result *= i;
                return result;
            }
            ;
            window.permutation = function(m, n) {
                m = Number(m);
                n = Number(n);
                if (isNaN(m) || isNaN(n) || m < 0 || n < 0 || m !== Math.floor(m) || n !== Math.floor(n))
                    throw new Error("Permutation args must be non-negative integers.");
                if (n > m)
                    throw new Error("In mAn, n cannot be greater than m.");
                if (n === 0)
                    return 1;
                if (m > 10 || n > 10)
                    throw new Error("Permutation arguments too large (max 10 for m, n).");
                let result = 1;
                for (let i = 0; i < n; i++)
                    result *= m - i;
                return result;
            }
            ;
            function updateDifficultyDisplay() {
                const difficultyElement = document.getElementById('difficultyDisplay');
                difficultyElement.className = 'difficulty-indicator';
                difficultyElement.classList.add(difficultySetting[currentDifficulty].class);
                difficultyElement.textContent = difficultySetting[currentDifficulty].name;
                document.querySelectorAll('.difficulty-btn').forEach(btn=>btn.classList.toggle('selected', btn.dataset.difficulty === currentDifficulty));
                updateBackgroundStyle();
            }
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            function generateNumberSegment() {
                return String(getRandomInt(1, 20));
            }
            function generateParenthesizedBinaryOpSegment() {
                const a = getRandomInt(1, 10);
                let b = getRandomInt(1, 10);
                const ops = ['+', '-', '*', '^', '^', '^', '^', '%']
                  , op = ops[Math.floor(Math.random() * ops.length)];
                if (op === '^') {
                    const typeOfPower = Math.random();
                    if (typeOfPower < .6) {
                        b = getRandomInt(2, 3);
                        return `(${a}^${b})`;
                    } else {
                        const baseForSqrt = getRandomInt(2, 5);
                        return `(${baseForSqrt * baseForSqrt}^(1/2))`;
                    }
                }
                if (op === '-' && a < b)
                    return `(${b}${op}${a})`;
                if (op === '%' && b === 0)
                    b = getRandomInt(1, 5);
                const needsParentheses = op === '^' || op === '%' || op === '*';
                return needsParentheses ? `(${a}${op}${b})` : `${a}${op}${b}`;
            }
            function generateFactorialSegment() {
                return `${getRandomInt(1, 5)}!`;
            }
            function generateFloorDivSegment() {
                return `[${getRandomInt(1, 10)}/${getRandomInt(2, 5)}]`;
            }
            function generatePermutationSegment() {
                let m = getRandomInt(2, 7)
                  , n = getRandomInt(1, m);
                return `${m}A ${n}`;
            }
            const segmentGenerators = [generateNumberSegment, generateParenthesizedBinaryOpSegment, generateFactorialSegment, generateFloorDivSegment, generatePermutationSegment];
            function isSimpleSegment(expr) {
                return /^\d+$|^(\d+)!$|^\d+A\d+$/.test(expr);
            }
            function isRedundantParentheses(segment) {
                if (segment.startsWith("(") && segment.endsWith(")")) {
                    const inner = segment.substring(1, segment.length - 1);
                    if (isSimpleSegment(inner))
                        return true;
                    if (inner.startsWith("(") && inner.endsWith(")") && checkBrackets(inner)) {
                        try {
                            const outerVal = safeEval(segment)
                              , innerVal = safeEval(inner);
                            if (Math.abs(outerVal - innerVal) < .0001)
                                return true;
                        } catch (e) {}
                    }
                }
                return false;
            }
            function generateSingleExpressionSegment() {
                let segment = ""
                  , attempts = 0;
                do {
                    const generator = segmentGenerators[Math.floor(Math.random() * segmentGenerators.length)];
                    segment = generator();
                    attempts++;
                    if (attempts > 20)
                        return String(getRandomInt(1, 10));
                    if (isRedundantParentheses(segment))
                        segment = segment.substring(1, segment.length - 1);
                } while (segment === "" || isRedundantParentheses(segment));
                return segment;
            }
            
            function generateFallbackEquation() {
                const a = getRandomInt(1, 9);
                return `${a}+${a}=${a + a}`;
            }
            function generateComplexLHS() {
                let expr = generateSingleExpressionSegment();
                const removeOuterParentheses = str=>{
                    if (str.startsWith("(") && str.endsWith(")") && checkBrackets(str.slice(1, -1)))
                        return str.slice(1, -1);
                    return str;
                };
                expr = removeOuterParentheses(expr);

                const currentMaxEqLength = debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH;
                let EqMargin = 5; 

                while (expr.length < currentMaxEqLength - EqMargin && Math.random() < 0.75) { 
                    const nextSegment = generateSingleExpressionSegment();
                    if (expr.length + nextSegment.length + 1 > currentMaxEqLength - EqMargin) { 
                        break; 
                    }

                    const ops = ['+', '-', '*', '%'];
                    const op = ops[Math.floor(Math.random() * ops.length)];

                    const shouldWrap = (segmentStr, operatorToApply) => {
                        if (isSimpleSegment(segmentStr)) return false;
                        if ((segmentStr.startsWith('(') && segmentStr.endsWith(')') && checkBrackets(segmentStr.substring(1, segmentStr.length - 1))) ||
                            (segmentStr.startsWith('[') && segmentStr.endsWith(']') && checkBrackets(segmentStr.substring(1, segmentStr.length - 1)))) {
                            return false;
                        }
                        if (operatorToApply === '*' || operatorToApply === '/' || operatorToApply === '%' || operatorToApply === '^') {
                            return true;
                        }
                        return false;
                    };

                    const exprNeedsParens = shouldWrap(expr, op);
                    const nextNeedsParens = shouldWrap(nextSegment, op);
                    
                    let tempNewExpr;
                    if (Math.random() < 0.5) {
                        tempNewExpr = `${exprNeedsParens ? '(' + expr + ')' : expr}${op}${nextNeedsParens ? '(' + nextSegment + ')' : nextSegment}`;
                    } else {
                        tempNewExpr = `${nextNeedsParens ? '(' + nextSegment + ')' : nextSegment}${op}${exprNeedsParens ? '(' + expr + ')' : expr}`;
                    }
                    try {
                        safeEval(tempNewExpr.substring(0, Math.min(tempNewExpr.length, 10))); 
                        expr = tempNewExpr;
                    } catch (e) {
                        break; 
                    }
                    
                    if (expr.length > 30) EqMargin = 7;
                    if (expr.length > 50) EqMargin = 9;
                }


                try {
                    const val = safeEval(expr);
                    if (!Number.isInteger(val) || expr.includes('.')) {
                        return String(getRandomInt(1, 30)); 
                    }
                } catch (e) {
                    return String(getRandomInt(1, 30));
                }
                return expr;
            }

            function generateRandomEquation() {
                let equation = '';
                let generationAttempts = 0;
                let internalDefaultMaxAttempts = (debugSettings.lockedLength > 0 || debugSettings.disableMaxLength) ? 300 : 80; 
                const maxTotalAttempts = (debugSettings.maxGenAttempts > 0 && debugSettings.maxGenAttempts >= 10) ? debugSettings.maxGenAttempts : internalDefaultMaxAttempts;
                
                while (generationAttempts < maxTotalAttempts) {
                    const opChance = Math.random();
                    let mainOperator;
                    if (currentDifficulty === "hard" && !isCustomLevel)
                        mainOperator = '=';
                    else {
                        if (opChance < .85)
                            mainOperator = '=';
                        else
                            mainOperator = '>';
                    }
                    let expr1_str, expr2_str;
                    if (mainOperator === '=') {
                        expr1_str = generateComplexLHS(); 
                        try {
                            const val1 = safeEval(expr1_str);
                            if (!Number.isInteger(val1) || expr1_str.includes('.')) {
                                generationAttempts++;
                                continue;
                            }
                            expr2_str = String(val1);
                        } catch (e) {
                            generationAttempts++;
                            continue;
                        }
                    } else { 
                        expr1_str = generateComplexLHS(); 
                        expr2_str = generateComplexLHS(); 
                        try {
                            let val1 = safeEval(expr1_str);
                            let val2 = safeEval(expr2_str);
                            if (!(val1 > val2)) {
                                if (val2 > val1 && (expr2_str + mainOperator + expr1_str).length <= (debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH)) {
                                    [expr1_str, expr2_str] = [expr2_str, expr1_str];
                                } else {
                                    let adjustment = getRandomInt(1, 5);
                                    if (Math.random() < 0.5 && (String(val1 + adjustment) + mainOperator + expr2_str).length <= (debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH)) {
                                        expr1_str = String(val1 + adjustment);
                                    } else if ((expr1_str + mainOperator + String(val2 - adjustment)).length <= (debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH) && val2 - adjustment >= 0) {
                                         expr2_str = String(val2 - adjustment);
                                         if (safeEval(expr1_str) <= safeEval(expr2_str)) { 
                                            generationAttempts++;
                                            continue;
                                         }
                                    } else { 
                                        generationAttempts++;
                                        continue;
                                    }
                                }
                            }
                        } catch (e) {
                            generationAttempts++;
                            continue;
                        }
                    }

                    if (expr1_str.includes('.') || expr2_str.includes('.')) {
                        generationAttempts++;
                        continue;
                    }
                    equation = `${expr1_str}${mainOperator}${expr2_str}`;

                    const currentMinLen = MIN_EQUATION_LENGTH;
                    const currentMaxLen = debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH;
                    let lengthOk = true;

                    if (debugSettings.lockedLength > 0) {
                        if (equation.length !== debugSettings.lockedLength) lengthOk = false;
                    } else {
                        if (equation.length < currentMinLen || equation.length > currentMaxLen) lengthOk = false;
                    }
                    
                    if (lengthOk && isValidEquation(equation.split(''), true)) {
                        break; 
                    }
                    generationAttempts++;
                }

                if (generationAttempts >= maxTotalAttempts || !equation || 
                    (debugSettings.lockedLength > 0 && equation.length !== debugSettings.lockedLength) ||
                    (!debugSettings.lockedLength && (equation.length < MIN_EQUATION_LENGTH || (!debugSettings.disableMaxLength && equation.length > DEFAULT_MAX_EQUATION_LENGTH)))
                   ) {
                    equation = generateFallbackEquation();
                     if (debugSettings.lockedLength > 0 && equation.length !== debugSettings.lockedLength) {
                        showMessage(`调试: 无法生成长度为 ${debugSettings.lockedLength} 的表达式. 使用备用表达式. (尝试次数: ${maxTotalAttempts})`, 3000);
                    } else if (generationAttempts >= maxTotalAttempts && (debugSettings.disableMaxLength || debugSettings.lockedLength > DEFAULT_MAX_EQUATION_LENGTH)) {
                        showMessage(`调试: 达到尝试上限 (${maxTotalAttempts}) 仍未生成所需长表达式. 使用备用表达式.`, 3000);
                    }
                }
                return equation;
            }
            function formatTime(totalSeconds) {
                const minutes = Math.floor(totalSeconds / 60)
                  , seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            
            function updateStatusIndicatorText(text, isTimer = false) {
                const indicator = document.getElementById('statusIndicator');
                if (!indicator) return;
            
                const newFinalText = (isTimer && text.startsWith("进行中:")) ?
                    `进行中: ${formatTime(gameActive && gameStartTime > 0 ? Math.floor((Date.now() - gameStartTime) / 1000) : elapsedSeconds)}`
                    : text;
            
                if (isStatusIndicatorAnimating) {
                    if (isTimer && indicator.classList.contains('timer-active') && indicator.textContent.startsWith("进行中:")) {
                        if(indicator.textContent !== newFinalText) {
                            indicator.classList.add('no-transition'); 
                            indicator.textContent = newFinalText;
                             requestAnimationFrame(() => indicator.classList.remove('no-transition'));
                        }
                    }
                    return; 
                }
            
                const oldText = indicator.textContent;
                const oldIsTimer = indicator.classList.contains('timer-active');
                const oldIsVisible = indicator.classList.contains('visible');
            
                const contentChanged = newFinalText !== oldText;
                const typeChanged = isTimer !== oldIsTimer;
            
                if (isTimer && oldIsTimer && oldIsVisible && contentChanged) {
                    indicator.classList.add('no-transition');
                    indicator.textContent = newFinalText;
                    requestAnimationFrame(() => indicator.classList.remove('no-transition'));
                    return;
                }
            
                if (contentChanged || typeChanged || (!oldIsVisible && newFinalText.trim() !== "")) {
                    if (oldIsVisible && (contentChanged || typeChanged)) {
                        isStatusIndicatorAnimating = true;
                        indicator.classList.remove('visible');
                        if (statusIndicatorAnimationTimeout) clearTimeout(statusIndicatorAnimationTimeout);
                        statusIndicatorAnimationTimeout = setTimeout(() => {
                            indicator.textContent = newFinalText;
                            indicator.classList.toggle('timer-active', isTimer);
                            requestAnimationFrame(() => { 
                                indicator.classList.add('visible');
                                isStatusIndicatorAnimating = false; 
                            });
                        }, 150);
                    } else {
                        indicator.textContent = newFinalText;
                        indicator.classList.toggle('timer-active', isTimer);
                        if (!oldIsVisible && newFinalText.trim() !== "") {
                           requestAnimationFrame(() => indicator.classList.add('visible'));
                        } else if (oldIsVisible && newFinalText.trim() === "" && !isTimer) {
                            indicator.classList.remove('visible');
                        }
                    }
                }
            }


                        function updateGameTimerDisplay() {
                if (!gameActive || !gameStartTime || isViewingHistoryState) {
                    if (gameTimerInterval) {
                        clearInterval(gameTimerInterval);
                        gameTimerInterval = null;
                    }
                    return;
                }
                elapsedSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
                if (statusIndicator.classList.contains('timer-active')) {
                    updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                }
                 if (debugSettings.suddenDeathTimer && elapsedSeconds >= 30) {
                    handleEndGame(false, 'LOST_SUDDEN_DEATH');
                    showMessage("时间到! 猝死模式失败!", 3000);
                }
            }
            
            function performLiveStatusUpdate() {
                if (!gameActive || isViewingHistoryState || currentRow >= ROWS) {
                    stopLiveStatusUpdates();
                    return;
                }

                if (debugSettings.vanishingInkMode) {
                    if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    } else {
                        updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                    }
                    return;
                }


                const currentInput = guessedEquation.slice(0, currentCol).join('');

                if (currentCol === 0 || currentInput.length === 0) {
                    if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    } else {
                        updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                    }
                    
                    return;
                }

                let lhs = currentInput;
                let mainOpIndex = -1;
                let depth = 0;
                for (let i = 0; i < currentInput.length; i++) {
                    const char = currentInput[i];
                    if (char === '(' || char === '[') depth++;
                    else if (char === ')' || char === ']') depth--;
                    else if (depth === 0 && (char === '=' || char === '>')) {
                        mainOpIndex = i;
                        break;
                    }
                }

                if (mainOpIndex !== -1) {
                    lhs = currentInput.substring(0, mainOpIndex);
                }

                if (lhs.length === 0) {
                    if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    } else {
                        updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                    }
                    return;
                }

                const lastCharOfLhs = lhs.trim().slice(-1);
                const requiresOperandAfter = ['+', '-', '*', '/', '%', '^', 'A'];
                if (requiresOperandAfter.includes(lastCharOfLhs)) {
                    if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    } else {
                         updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                    }
                    return;
                }
                
                if (lhs.length === 1 && (lhs === '(' || lhs === '[' || !/\d/.test(lhs[0]))) {
                    if (lhs.length === 1 && (lhs === '!' || lhs === ')')) {
                    } else if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                        return;
                    } else {
                        updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                        return;
                    }
                }

                try {
                    const result = safeEval(lhs);
                    if (typeof result === 'number' && !isNaN(result)) {
                        let formattedLHS = lhs.replace(/\*/g, '×').replace(/\//g, '÷');
                        let previewText = `${formattedLHS} = ${Number(result.toFixed(3)).toString()}`;
                        if (previewText.length > 35) {
                            previewText = previewText.substring(0, 32) + "...";
                        }
                        updateStatusIndicatorText(previewText, false);
                    } else {
                        if (gameStartTime > 0) {
                            updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                        } else {
                            updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                        }
                    }
                } catch (e) {
                    if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    } else {
                       updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                    }
                }
            }

            function startLiveStatusUpdates() {
                if (!liveStatusUpdateInterval && gameActive && !isViewingHistoryState) {
                    if (gameStartTime > 0 && statusIndicator.classList.contains('timer-active')) {
                    } else {
                         performLiveStatusUpdate(); 
                    }
                    liveStatusUpdateInterval = setInterval(performLiveStatusUpdate, LIVE_STATUS_UPDATE_INTERVAL_MS);
                }
            }

            function stopLiveStatusUpdates() {
                if (liveStatusUpdateInterval) {
                    clearInterval(liveStatusUpdateInterval);
                    liveStatusUpdateInterval = null;
                }
            }

                        function handleSubmit() {
                if (!gameActive || isViewingHistoryState)
                    return;
                
                stopLiveStatusUpdates();
                
                const currentBoardRowElement = document.querySelector(`.board .row:nth-child(${currentRow + 1})`);
                if (currentCol < COLS && !debugSettings.unknownLengthMode) { 
                    if (currentBoardRowElement)
                        currentBoardRowElement.classList.add('invalid-shake');
                    setTimeout(()=>{
                        if (currentBoardRowElement)
                            currentBoardRowElement.classList.remove('invalid-shake');
                    }
                    , 500);
                    showMessage("请填满当前行");
                    startLiveStatusUpdates();
                    return;
                }

                if (!isValidEquation(guessedEquation.slice(0, currentCol))) { 
                    if (currentBoardRowElement)
                        currentBoardRowElement.classList.add('invalid-shake');
                    setTimeout(()=>{
                        if (currentBoardRowElement)
                            currentBoardRowElement.classList.remove('invalid-shake');
                    }
                    , 500);
                    startLiveStatusUpdates();
                    return;
                }
                let justStartedTimerAndDisplayedIt = false;
                if (!gameStartTime && (currentCol === COLS || debugSettings.unknownLengthMode) ) { 
                    if (!debugSettings.suddenDeathTimer) { 
                        gameStartTime = Date.now();
                        elapsedSeconds = 0;
                        gameTimerInterval = setInterval(updateGameTimerDisplay, 1000);
                    }
                    updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    justStartedTimerAndDisplayedIt = true;
                }
                guessedEquationsHistory.push(guessedEquation.slice(0, currentCol).join(''));
                checkGuess();
                const guessString = guessedEquation.slice(0, currentCol).join('');
                if (guessString === targetEquation) {
                    const tilesToDance = currentBoardRowElement ? Array.from(currentBoardRowElement.children) : [];
                    tilesToDance.forEach((tile,i)=>{
                        setTimeout(()=>tile.classList.add('win-dance'), i * 100);
                    }
                    );
                    handleEndGame(true, 'WON');
                    return;
                }
                if (guessString !== targetEquation) {
                   currentRow++;
                   currentCol = 0;
                }
                
                const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS;
                guessedEquation = Array(displayCols).fill('');

                if (currentRow >= ROWS) {
                    if (currentBoardRowElement)
                        currentBoardRowElement.classList.add('invalid-shake');
                    setTimeout(()=>{
                        if (currentBoardRowElement)
                            currentBoardRowElement.classList.remove('invalid-shake');
                    }
                    , 600);
                    handleEndGame(false, 'LOST');
                } else {
                    if (!justStartedTimerAndDisplayedIt) { 
                        if (gameStartTime > 0) { 
                            updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                        } else { 
                             updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                        }
                    }
                }
            }
            function initBoard() {
                const board = document.getElementById('board');
                board.innerHTML = '';
                const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS; 
                board.style.gridTemplateRows = `repeat(${ROWS},1fr)`;

                for (let i = 0; i < ROWS; i++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row';
                    rowDiv.style.gridTemplateColumns = `repeat(${displayCols},1fr)`;
                    for (let j = 0; j < displayCols; j++) {
                        const tileDiv = document.createElement('div');
                        tileDiv.className = 'tile tile-new-game-appear';
                        tileDiv.id = `tile-${i}-${j}`;
                        tileDiv.style.animationDelay = `${i * .05 + j * .02}s`;
                        if (debugSettings.unknownLengthMode && (COLS === 0 || j >= COLS) ) { 
                             tileDiv.classList.add('unknown-length');
                        }
                        rowDiv.appendChild(tileDiv);
                    }
                    board.appendChild(rowDiv);
                }
                setTimeout(()=>{
                    document.querySelectorAll('.tile-new-game-appear').forEach(t=>t.classList.remove('tile-new-game-appear'));
                }
                , ROWS * .05 * 1e3 + displayCols * .02 * 1e3 + 500);
            }
            function isTouchDevice() {
                return 'ontouchstart'in window || navigator.maxTouchPoints > 0;
            }
            function initKeyboard() {
                const keyboardElement = document.getElementById('keyboard');
                keyboardElement.innerHTML = '';
                keyboardElement.classList.remove('disabled-input', 'true-random-keys');

                const keyLayout = [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'], ['+', '-', '×', '÷', '%', '^', '>', '!'], ['A', '(', ')', '[', ']', '='], ['AC', '删除', '提交']];
                
                if (debugSettings.randomKeyboardLayout) {
                    keyboardElement.classList.add('true-random-keys');
                    const allChars = [];
                    keyLayout.forEach(row => row.forEach(key => {
                        if (key !== 'AC' && key !== '删除' && key !== '提交') allChars.push(key);
                    }));
                    allChars.sort(() => Math.random() - 0.5); 
                    let charIdx = 0;
                    keyLayout.forEach((row, rIdx) => {
                        keyLayout[rIdx] = row.map(key => {
                            if (key !== 'AC' && key !== '删除' && key !== '提交') {
                                return allChars[charIdx++];
                            }
                            return key;
                        });
                    });
                }


                keyLayout.forEach(rowKeys=>{
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'keyboard-row';
                    rowKeys.forEach(keyText=>{
                        const key = document.createElement('div');
                        key.className = 'key';
                        key.textContent = keyText;
                        let internalKeyValue = keyText;
                        if (keyText === '×')
                            internalKeyValue = '*';
                        if (keyText === '÷')
                            internalKeyValue = '/';
                        if (keyText === 'AC') {
                            key.classList.add('wide');
                            key.addEventListener('click', handleClearAllCurrentRow);
                        } else if (keyText === '删除') {
                            key.classList.add('wide');
                            key.addEventListener('click', handleDelete);
                        } else if (keyText === '提交') {
                            key.classList.add('super-wide');
                            key.addEventListener('click', handleSubmit);
                        } else {
                            key.dataset.char = internalKeyValue;
                            key.addEventListener('click', event=>handleKeyPress(internalKeyValue, event.currentTarget));
                            if (debugSettings.randomKeyboardLayout) {
                                key.style.setProperty('--random-order', Math.floor(Math.random() * 100));
                            }
                        }
                        addKeyAnimationListeners(key);
                        if (keyTooltips[internalKeyValue]) {
                            key.classList.add('operator-key');
                            const tooltipSpan = document.createElement('span');
                            tooltipSpan.className = 'key-tooltip';
                            tooltipSpan.textContent = keyTooltips[internalKeyValue];
                            key.appendChild(tooltipSpan);
                            key.addEventListener('mouseenter', ()=>{
                                if (!isTouchDevice())
                                    key.classList.add('show-tooltip');
                            }
                            );
                            key.addEventListener('mouseleave', ()=>{
                                if (!isTouchDevice())
                                    key.classList.remove('show-tooltip');
                            }
                            );
                            key.addEventListener('touchstart', e=>{
                                if (isTouchDevice()) {
                                    if (activeTooltipKey && activeTooltipKey !== key)
                                        activeTooltipKey.classList.remove('show-tooltip');
                                    clearTimeout(activeTooltipTimeout);
                                    key.classList.add('show-tooltip');
                                    activeTooltipKey = key;
                                    activeTooltipTimeout = setTimeout(()=>{
                                        if (activeTooltipKey === key) {
                                            key.classList.remove('show-tooltip');
                                            activeTooltipKey = null;
                                        }
                                    }
                                    , 2500);
                                }
                            }
                            , {
                                passive: true
                            });
                        }
                        rowDiv.appendChild(key);
                    }
                    );
                    keyboardElement.appendChild(rowDiv);
                }
                );
                 if (debugSettings.grayKeysUnclickable) {
                    document.querySelectorAll('.key.absent').forEach(k => k.classList.add('disabled-permanently'));
                }
            }
            function addKeyAnimationListeners(keyEl) {
                keyEl.addEventListener('mousedown', ()=>keyEl.classList.add('pressed'));
                keyEl.addEventListener('mouseup', ()=>keyEl.classList.remove('pressed'));
                keyEl.addEventListener('mouseleave', ()=>{
                    keyEl.classList.remove('pressed');
                    if (isTouchDevice() && activeTooltipKey === keyEl)
                        return;
                    keyEl.classList.remove('show-tooltip');
                }
                );
                keyEl.addEventListener('touchstart', e=>{
                    keyEl.classList.add('pressed');
                }
                , {
                    passive: true
                });
                keyEl.addEventListener('touchend', ()=>keyEl.classList.remove('pressed'));
            }
            function resetKeyboardColors() {
                document.querySelectorAll('.key').forEach(k=>k.classList.remove('correct', 'present', 'absent', 'disabled-permanently', 'disabled-view-mode'));
                document.getElementById('keyboard').classList.remove('disabled-input');
            }
                        function startGame(newTargetEquation, newDifficultyKey) {
                gameActive = true;
                currentRow = 0;
                currentCol = 0;
                isViewingHistoryState = false;
                viewingHistoryItem = null;
                guessedEquationsHistory = [];
                gameStartTime = 0; 
                elapsedSeconds = 0;
                if (gameTimerInterval) { 
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;
                }
                
                stopLiveStatusUpdates();
                
                enableKeyboardForPlay();
                restartBtn.title = "重新开始/投降";
                restartBtn.innerHTML = '🔄';

                if (newTargetEquation && newDifficultyKey && difficultySetting[newDifficultyKey]) { 
                    targetEquation = newTargetEquation;
                    currentDifficulty = newDifficultyKey;
                    isCustomLevel = true;
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'custom');
                } else if (debugSettings.useCustomExpressionForNextGame && debugSettings.customExpression) {
                    const customExprValid = isValidEquation(debugSettings.customExpression.split(''), true);
                    const exprLen = debugSettings.customExpression.length;
                    const currentMaxLen = debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH;
                    const currentMinLen = MIN_EQUATION_LENGTH;
                    let lengthConstraintOk = true;
                    if (debugSettings.lockedLength > 0) {
                        if (exprLen !== debugSettings.lockedLength) lengthConstraintOk = false;
                    } else {
                        if (exprLen < currentMinLen || exprLen > currentMaxLen) lengthConstraintOk = false;
                    }

                    if (customExprValid && lengthConstraintOk) {
                        targetEquation = debugSettings.customExpression;
                        isCustomLevel = true; 
                        setHeaderTitleState(quarkModeActive ? 'quark' : 'debug');
                        showMessage("调试: 使用自定义表达式!", 1500);
                    } else {
                        if (!customExprValid) showMessage("调试: 自定义表达式无效. 生成随机表达式.", 2000);
                        else if (!lengthConstraintOk) showMessage("调试: 自定义表达式长度不符. 生成随机表达式.", 2000);
                        targetEquation = generateRandomEquation();
                        isCustomLevel = false;
                         if (!quarkModeActive) setHeaderTitleState('idle');
                         else setHeaderTitleState(headerTitleElement.classList.contains('state-quark') ? 'quark' : 'idle'); 
                    }
                    debugSettings.useCustomExpressionForNextGame = false;
                    if (document.getElementById('debugModal').classList.contains('show')) {
                        document.getElementById('debugCustomExpr').value = "";
                    }
                } else { 
                    isCustomLevel = false;
                    const savedDiff = localStorage.getItem('sumzleDifficulty');
                    if (difficultySetting[savedDiff])
                        currentDifficulty = savedDiff;
                    else
                        currentDifficulty = 'medium';
                    targetEquation = generateRandomEquation();
                    if (!quarkModeActive) setHeaderTitleState('idle');
                    else setHeaderTitleState('quark');
                }
                
                ROWS = debugSettings.oneTryMode ? 1 : difficultySetting[currentDifficulty].attempts;
                COLS = debugSettings.unknownLengthMode ? 0 : targetEquation.length; 
                
                if(debugSettings.suddenDeathTimer) { 
                    gameStartTime = Date.now();
                    elapsedSeconds = 0; 
                    gameTimerInterval = setInterval(updateGameTimerDisplay, 1000);
                }

                const displayColsForGuessedArray = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS > 0 ? COLS : targetEquation.length;
                guessedEquation = Array(displayColsForGuessedArray).fill(''); 
                
                initBoard();
                initKeyboard();
                resetKeyboardColors();
                updateDifficultyDisplay();
                updateStatusIndicatorText(
                    `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`,
                    debugSettings.suddenDeathTimer 
                );
                document.getElementById('exportImageBtn').style.display = 'none';
                document.getElementById('shareLevelBtn').style.display = isCustomLevel || !gameActive ? 'inline-block' : 'none';
                updateBackgroundStyle();
            }
            function resetGame() {
                isCustomLevel = false;
                const savedDiff = localStorage.getItem('sumzleDifficulty');
                if (difficultySetting[savedDiff])
                    currentDifficulty = savedDiff;
                else
                    currentDifficulty = 'medium';
                ROWS = difficultySetting[currentDifficulty].attempts;

                if (quarkModeActive) {
                    setupTitleSpans(ORIGINAL_TITLE_TEXT);
                    if (titleFallAnimation.originalComputedTransition) {
                        headerTitleElement.style.transition = titleFallAnimation.originalComputedTransition;
                    } else {
                         headerTitleElement.style.transition = 'top .8s cubic-bezier(0.6, -0.28, 0.735, 0.045), opacity .5s ease-out';
                    }
                    quarkModeActive = false; 
                    sumzleEasterEggActivated = false; 
                    sumzleTitleClickCount = 0;
                    quarkDebugClickCount = 0; 
                    headerTitleElement.style.top = titleFallAnimation.originalComputedTop;
                    headerTitleElement.style.transform = 'translateX(-50%)';
                    headerTitleElement.style.opacity = '1';
                    titleFallAnimation.active = false;
                    headerTitleElement.style.pointerEvents = 'auto';
                }
                startGame(null, null);
            }
            function updateStatsDisplay() {
                const rootStyles = getComputedStyle(document.documentElement)
                  , gridColor = rootStyles.getPropertyValue('--chart-grid-color').trim()
                  , tickColor = rootStyles.getPropertyValue('--chart-tick-color').trim()
                  , titleColor = rootStyles.getPropertyValue('--chart-title-color').trim()
                  , legendLabelColor = rootStyles.getPropertyValue('--chart-legend-label-color').trim();
                const titleTextColor = currentTheme === 'dark' ? '#f0f0f0' : titleColor;
                const legendTextColor = currentTheme === 'dark' ? '#e0e0e0' : legendLabelColor;
                const lbls = ['简单', '中等', '困难', '总体']
                  , pD = [stats.byDifficulty.easy.gamesPlayed, stats.byDifficulty.medium.gamesPlayed, stats.byDifficulty.hard.gamesPlayed, stats.total.gamesPlayed]
                  , wD = [stats.byDifficulty.easy.gamesWon, stats.byDifficulty.medium.gamesWon, stats.byDifficulty.hard.gamesWon, stats.total.gamesWon];
                const data = {
                    labels: lbls,
                    datasets: [{
                        label: '已玩',
                        data: pD,
                        backgroundColor: currentTheme === 'dark' ? 'rgba(100,130,200,.7)' : 'rgba(201,180,88,.6)',
                        borderColor: currentTheme === 'dark' ? 'rgba(100,130,200,1)' : 'rgba(201,180,88,1)',
                        borderWidth: 1
                    }, {
                        label: '获胜',
                        data: wD,
                        backgroundColor: currentTheme === 'dark' ? 'rgba(80,160,120,.7)' : 'rgba(106,170,100,.6)',
                        borderColor: currentTheme === 'dark' ? 'rgba(80,160,120,1)' : 'rgba(106,170,100,1)',
                        borderWidth: 1
                    }]
                };
                const cfg = {
                    type: 'bar',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                grace: '5%',
                                ticks: {
                                    color: tickColor,
                                    font: {
                                        size: 11
                                    }
                                },
                                grid: {
                                    color: gridColor,
                                    drawBorder: false
                                }
                            },
                            x: {
                                ticks: {
                                    color: tickColor,
                                    font: {
                                        size: 12
                                    }
                                },
                                grid: {
                                    display: false,
                                    drawBorder: false
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `最佳连胜: ${stats.total.bestStreak} | 当前连胜: ${stats.total.currentStreak}`,
                                font: {
                                    size: 14,
                                    weight: '500'
                                },
                                color: titleTextColor,
                                padding: {
                                    top: 5,
                                    bottom: 15
                                }
                            },
                            legend: {
                                labels: {
                                    color: legendTextColor,
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: currentTheme === 'dark' ? 'rgba(40,40,40,.9)' : 'rgba(20,20,20,.9)',
                                titleColor: currentTheme === 'dark' ? '#f0f0f0' : '#fff',
                                bodyColor: currentTheme === 'dark' ? '#e0e0e0' : '#ddd',
                                callbacks: {
                                    afterLabel: ctx=>{
                                        if (ctx.datasetIndex === 1) {
                                            const pl = pD[ctx.dataIndex]
                                              , wn = wD[ctx.dataIndex];
                                            return `胜率: ${pl > 0 ? Math.round(wn / pl * 100) : 0}%`;
                                        }
                                    }
                                }
                            }
                        },
                        color: titleColor
                    }
                };
                const chartEl = document.getElementById('statsChart');
                if (statsChartInstance)
                    statsChartInstance.destroy();
                if (chartEl) {
                    try {
                        if (typeof Chart === 'undefined') {
                            chartEl.innerHTML = '';
                            const noChartMsg = document.createElement('p');
                            noChartMsg.textContent = "统计图表暂时无法加载。";
                            noChartMsg.style.textAlign = 'center';
                            noChartMsg.style.padding = '20px';
                            noChartMsg.style.color = 'var(--color-text-secondary)';
                            chartEl.appendChild(noChartMsg);
                            statsChartInstance = null;
                        } else {
                            const existingMsg = chartEl.querySelector('p');
                            if (existingMsg && existingMsg.textContent.includes("无法加载"))
                                existingMsg.remove();
                            statsChartInstance = new Chart(chartEl,cfg);
                        }
                    } catch (e) {
                        statsChartInstance = null;
                        chartEl.innerHTML = '';
                        const errorMsg = document.createElement('p');
                        errorMsg.textContent = "加载统计图表时出错。";
                        errorMsg.style.textAlign = 'center';
                        errorMsg.style.padding = '20px';
                        errorMsg.style.color = 'var(--color-text-secondary)';
                        chartEl.appendChild(errorMsg);
                    }
                }
                const gpEl = document.getElementById('gamesPlayed');
                if (gpEl)
                    gpEl.textContent = stats.total.gamesPlayed;
                const gwEl = document.getElementById('gamesWon');
                if (gwEl)
                    gwEl.textContent = stats.total.gamesWon;
                const csEl = document.getElementById('currentStreak');
                if (csEl)
                    csEl.textContent = stats.total.currentStreak;
            }
            function clearStatistics() {
                showModal('confirmClearStatsModal');
            }
            document.getElementById('executeClearStatsBtn').addEventListener('click', ()=>{
                stats = JSON.parse(JSON.stringify(initialStats));
                saveStats();
                updateStatsDisplay();
                hideModal('confirmClearStatsModal');
                showMessage("统计数据已清空");
            }
            );
            document.getElementById('cancelClearStatsBtn').addEventListener('click', ()=>{
                hideModal('confirmClearStatsModal');
            }
            );
            function handleKeyPress(char, keyElement = null) {
                const currentDisplayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS;
                if (!gameActive || currentCol >= currentDisplayCols || isViewingHistoryState || isClearingRowWithAnimation || document.getElementById('keyboard').classList.contains('disabled-input'))
                    return;

                if (keyElement && keyElement.classList.contains('disabled-permanently'))
                    return;

                let charToDisplay = char;
                if (debugSettings.mirrorInputMode && mirrorMap[char]) {
                    charToDisplay = mirrorMap[char];
                }

                playSound('keyPress');
                const tile = document.getElementById(`tile-${currentRow}-${currentCol}`);
                if (!tile) return;

                guessedEquation[currentCol] = charToDisplay;
                tile.classList.add('filled');
                tile.classList.remove('unknown-length');
                
                const tileForVanishing = tile;
                const charOriginallyTyped = charToDisplay;

                tileForVanishing.textContent = displayChar(charOriginallyTyped);
                tileForVanishing.classList.add('pop');

                if (debugSettings.vanishingInkMode) {
                    tileForVanishing.style.transition = 'none';
                    tileForVanishing.style.opacity = '1';

                    setTimeout(() => {
                        if (tileForVanishing.textContent === displayChar(charOriginallyTyped)) {
                            tileForVanishing.style.transition = 'opacity 0.4s ease-out';
                            tileForVanishing.style.opacity = '0.05';
                        }
                    }, 600); 

                    setTimeout(() => {
                        if (tileForVanishing.textContent === displayChar(charOriginallyTyped) || 
                            (tileForVanishing.style.opacity !== '' && parseFloat(tileForVanishing.style.opacity) < 1)) {
                            tileForVanishing.textContent = '';
                        }
                        
                        if (!tileForVanishing.classList.contains('correct') &&
                            !tileForVanishing.classList.contains('present') &&
                            !tileForVanishing.classList.contains('absent')) {
                            tileForVanishing.style.opacity = '1';
                            tileForVanishing.style.transition = 'none';
                        }
                    }, 1000);
                } else {
                    tileForVanishing.style.opacity = '1';
                    tileForVanishing.style.transition = 'none';
                }
                setTimeout(() => tileForVanishing.classList.remove('pop'), 200);


                const keyRect = keyElement ? keyElement.getBoundingClientRect() : null;
                const tileRect = tile.getBoundingClientRect();
                if (keyElement && window.getComputedStyle(keyElement).display !== 'none' && keyRect) {
                    const flyingChar = document.createElement('div');
                    flyingChar.textContent = displayChar(charToDisplay);
                    flyingChar.classList.add('flying-char-effect');
                    const keyStyle = window.getComputedStyle(keyElement);
                    flyingChar.style.fontSize = keyStyle.fontSize;
                    flyingChar.style.fontWeight = keyStyle.fontWeight;
                    flyingChar.style.fontFamily = keyStyle.fontFamily;
                    flyingChar.style.padding = keyStyle.padding;
                    flyingChar.style.backgroundColor = keyStyle.backgroundColor;
                    flyingChar.style.color = isEffectivelyDarkMode() ? getComputedStyle(document.documentElement).getPropertyValue('--color-surface').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-text').trim();
                    flyingChar.style.borderRadius = keyStyle.borderRadius;
                    flyingChar.style.left = `${keyRect.left}px`;
                    flyingChar.style.top = `${keyRect.top}px`;
                    flyingChar.style.width = `${keyRect.width}px`;
                    flyingChar.style.height = `${keyRect.height}px`;
                    document.body.appendChild(flyingChar);
                    requestAnimationFrame(() => {
                        const targetLeft = tileRect.left + (tileRect.width - keyRect.width) / 2;
                        const targetTop = tileRect.top + (tileRect.height - keyRect.height) / 2;
                        const translateX = targetLeft - keyRect.left;
                        const translateY = targetTop - keyRect.top;
                        flyingChar.style.transform = `translate(${translateX}px, ${translateY}px) scale(.5)`;
                        flyingChar.style.opacity = '0';
                    });
                    flyingChar.addEventListener('transitionend', () => {
                        if (flyingChar.parentElement)
                            flyingChar.parentElement.removeChild(flyingChar);
                    }, {
                        once: true
                    });
                }
                currentCol++;
                startLiveStatusUpdates();
            }
            function handleClearAllCurrentRow() {
                if (!gameActive || currentCol === 0 || isViewingHistoryState || isClearingRowWithAnimation || document.getElementById('keyboard').classList.contains('disabled-input'))
                    return;
                
                stopLiveStatusUpdates();

                isClearingRowWithAnimation = true;
                document.getElementById('keyboard').classList.add('disabled-input');
                playSound('keyPress');
                
                for (let col = currentCol - 1; col >= 0; col--) {
                    const tile = document.getElementById(`tile-${currentRow}-${col}`);
                    if (tile && tile.classList.contains('filled')) {
                        setTimeout(()=>{
                            tile.textContent = '';
                            tile.classList.remove('filled');
                            tile.style.opacity = '1';
                            tile.style.transition = 'none';
                            if (debugSettings.unknownLengthMode && (COLS === 0 || col >= COLS)) tile.classList.add('unknown-length');
                            tile.classList.add('tile-cleared-animation');
                            setTimeout(()=>tile.classList.remove('tile-cleared-animation'), 300);
                        }
                        , (currentCol - 1 - col) * 60);
                    }
                    guessedEquation[col] = '';
                }
                const totalAnimationTime = currentCol > 0 ? (currentCol - 1) * 60 + 350 : 0;
                currentCol = 0;

                setTimeout(()=>{
                    isClearingRowWithAnimation = false;
                    document.getElementById('keyboard').classList.remove('disabled-input');
                    performLiveStatusUpdate();
                }
                , totalAnimationTime);
            }
            function handleDelete() {
                if (!gameActive || currentCol <= 0 || isViewingHistoryState || isClearingRowWithAnimation || document.getElementById('keyboard').classList.contains('disabled-input'))
                    return;

                playSound('keyPress');
                currentCol--;
                guessedEquation[currentCol] = '';
                const tile = document.getElementById(`tile-${currentRow}-${currentCol}`);
                tile.textContent = '';
                tile.classList.remove('filled');
                tile.style.opacity = '1'; 
                tile.style.transition = 'none'; 
                if (debugSettings.unknownLengthMode && (COLS === 0 || currentCol >= COLS) ) tile.classList.add('unknown-length');


                if (currentCol === 0) {
                    
                    if (gameStartTime > 0) {
                        updateStatusIndicatorText(`进行中: ${formatTime(elapsedSeconds)}`, true);
                    } else {
                         updateStatusIndicatorText(`${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`, false);
                    }
                } else {
                    performLiveStatusUpdate();
                }
            }
            function safeEval(expr) {
                let safeExpr = expr;
                for (let k = 0; k < 3; k++)
                    safeExpr = safeExpr.replace(/\[(.*?)\]/g, (match,innerExpr)=>`truncate((${innerExpr}))`);
                for (let i = 0; i < 3; i++) {
                    safeExpr = safeExpr.replace(/(\d+)A(\d+)/g, "permutation($1,$2)");
                    safeExpr = safeExpr.replace(/(\d+)!/g, "factorial($1)");
                    safeExpr = safeExpr.replace(/\((.+?)\)!/g, (match,innerExpr)=>`factorial((${innerExpr}))`);
                    safeExpr = safeExpr.replace(/\((.+?)\)A(\d+)/g, (match,innerExpr,n)=>`permutation((${innerExpr}),${n})`);
                    safeExpr = safeExpr.replace(/(\d+)A\((.+?)\)/g, (match,m,innerExpr)=>`permutation(${m},(${innerExpr}))`);
                    safeExpr = safeExpr.replace(/\((.+?)\)A\((.+?)\)/g, (match,innerM,innerN)=>`permutation((${innerM}),(${innerN}))`);
                }
                safeExpr = safeExpr.replace(/\^/g, '**');
                const evalAllowedChars = /^[0-9+\-*/%()!^*.<>\sacefilmoprtun]+$/i;
                if (!evalAllowedChars.test(safeExpr.replace(/,/g, '')))
                    throw new Error("Invalid chars for eval.");
                try {
                    return Function('factorial', 'permutation', 'truncate', 'return (' + safeExpr + ')')(window.factorial, window.permutation, Math.trunc);
                } catch (e) {
                    throw e;
                }
            }
            function checkBrackets(exprString) {
                const stack = []
                  , map = {
                    '(': ')',
                    '[': ']'
                };
                for (let char of exprString) {
                    if (char === '(' || char === '[')
                        stack.push(char);
                    else if (char === ')' || char === ']') {
                        if (stack.length === 0)
                            return false;
                        const lastOpen = stack.pop();
                        if (map[lastOpen] !== char)
                            return false;
                    }
                }
                return stack.length === 0;
            }
            function checkModuloOperation(exprString) {
                const parts = exprString.split('%');
                if (parts.length > 1) {
                    for (let i = 1; i < parts.length; i++) {
                        let divisorPart = ""
                          , depth = 0;
                        for (let j = 0; j < parts[i].length; j++) {
                            const char = parts[i][j];
                            if (char === '(' || char === '[')
                                depth++;
                            else if (char === ')' || char === ']')
                                depth--;
                            if (depth < 0)
                                break;
                            divisorPart += char;
                            if (depth === 0 && (j === parts[i].length - 1 || !'0123456789.()[]'.includes(parts[i][j + 1])))
                                break;
                        }
                        if (divisorPart) {
                            try {
                                const divVal = safeEval(divisorPart);
                                if (divVal === 0 || !Number.isInteger(divVal))
                                    return false;
                            } catch (e) {
                                return false;
                            }
                        } else
                            return false;
                    }
                }
                return true;
            }
            function isValidEquation(equationArray, isGenerationContext=false) {
                const cleanEquation = equationArray.join('');
                if (!isGenerationContext && cleanEquation.includes('.')) {
                    showMessage("输入不能包含小数点");
                    return false;
                }
                if (!isGenerationContext && /(?<![\.\d])0\d+/.test(cleanEquation)) {
                    showMessage("数字不能以0开头 (除非是0本身)");
                    return false;
                }
                if (!isGenerationContext && !checkModuloOperation(cleanEquation)) {
                    showMessage("取模运算中除数不能为0或小数");
                    return false;
                }
                let mainOp = null
                  , mainOpIndex = -1
                  , depth = 0;
                for (let i = 0; i < cleanEquation.length; i++) {
                    const char = cleanEquation[i];
                    if (char === '(' || char === '[')
                        depth++;
                    else if (char === ')' || char === ']')
                        depth--;
                    else if (depth === 0 && (char === '=' || char === '>')) {
                        if (mainOp !== null) {
                            if (!isGenerationContext)
                                showMessage("只能有一个主操作符");
                            return false;
                        }
                        mainOp = char;
                        mainOpIndex = i;
                    }
                }
                if (!mainOp) {
                    if (!isGenerationContext)
                        showMessage("必须包含 = 或 >");
                    return false;
                }
                const leftSide = cleanEquation.substring(0, mainOpIndex)
                  , rightSide = cleanEquation.substring(mainOpIndex + 1);
                if (leftSide.length === 0 || rightSide.length === 0) {
                    if (!isGenerationContext)
                        showMessage("操作符两边需有表达式");
                    return false;
                }
                if (!checkBrackets(leftSide) || !checkBrackets(rightSide)) {
                    if (!isGenerationContext)
                        showMessage("括号不匹配");
                    return false;
                }
                try {
                    const evalLeft = safeEval(leftSide)
                      , evalRight = safeEval(rightSide);
                    if (typeof evalLeft !== 'number' || typeof evalRight !== 'number' || isNaN(evalLeft) || isNaN(evalRight)) {
                        if (!isGenerationContext)
                            showMessage("表达式计算结果无效");
                        return false;
                    }
                    let statementTrue = false;
                    if (mainOp === '=')
                        statementTrue = Math.abs(evalLeft - evalRight) < .0001;
                    else if (mainOp === '>')
                        statementTrue = evalLeft > evalRight;
                    if (!statementTrue) {
                        if (!isGenerationContext)
                            showMessage("等式/不等式不成立");
                        return false;
                    }
                    if (!Number.isInteger(evalLeft) || !Number.isInteger(evalRight)) {
                        if (Math.abs(evalLeft - Math.round(evalLeft)) > .0001 || Math.abs(evalRight - Math.round(evalRight)) > .0001) {
                            if (!isGenerationContext)
                                showMessage("结果必须为整数");
                            return false;
                        }
                    }
                } catch (e) {
                    if (!isGenerationContext)
                        showMessage(`无效表达式: ${e.message}`);
                    return false;
                }
                return true;
            }
            function triggerConfetti() {
                const confettiContainer = document.getElementById('confettiOverlay');
                if (!confettiContainer)
                    return;
                for (let i = 0; i < 60; i++) {
                    const confettiPiece = document.createElement('div');
                    confettiPiece.classList.add('confetti-piece');
                    confettiPiece.style.width = `${getRandomInt(6, 12)}px`;
                    confettiPiece.style.height = confettiPiece.style.width;
                    confettiPiece.style.backgroundColor = `hsl(${Math.random() * 360},100%,70%)`;
                    confettiPiece.style.left = `${Math.random() * 100}%`;
                    confettiPiece.style.top = `${-20 - Math.random() * 30}%`;
                    confettiPiece.style.opacity = '0';
                    confettiPiece.style.transform = `rotate(${Math.random() * 360}deg)`;
                    const animationDuration = Math.random() * 2 + 4;
                    confettiPiece.style.transitionDuration = `${animationDuration}s,${animationDuration}s,${animationDuration * .4}s`;
                    confettiContainer.appendChild(confettiPiece);
                    setTimeout(()=>{
                        confettiPiece.style.opacity = '1';
                        confettiPiece.style.top = '110%';
                        confettiPiece.style.transform = `rotate(${Math.random() * 720 + 360}deg) translateX(${Math.random() * 150 - 75}px)`;
                    }
                    , 50 + Math.random() * 100);
                    setTimeout(()=>{
                        if (confettiPiece.parentElement)
                            confettiPiece.parentElement.removeChild(confettiPiece);
                    }
                    , animationDuration * 1e3 + 200);
                }
            }
            let messageTimeout;
            function handleEndGame(isWin, statusString) {
                gameActive = false;
                if (gameTimerInterval) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;
                }
                if (debugSettings.suddenDeathIntervalId) {
                    clearInterval(debugSettings.suddenDeathIntervalId);
                    debugSettings.suddenDeathIntervalId = null;
                }
                
                stopLiveStatusUpdates();


                let finalMessage = "";
                const displayTargetEquation = targetEquation.replace(/\*/g, '×').replace(/\//g, '÷');
                if (isWin) {
                    playSound('success');
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'win');
                    if (!isCustomLevel || isViewingHistoryState) {
                        stats.total.gamesPlayed++;
                        stats.total.gamesWon++;
                        stats.total.currentStreak++;
                        stats.total.bestStreak = Math.max(stats.total.bestStreak, stats.total.currentStreak);
                        stats.byDifficulty[currentDifficulty].gamesPlayed++;
                        stats.byDifficulty[currentDifficulty].gamesWon++;
                        saveStats();
                    }
                    finalMessage = `恭喜你猜对了！ 🎉`;
                    if (elapsedSeconds > 0)
                        updateStatusIndicatorText(`胜利! 用时: ${formatTime(elapsedSeconds)}`);
                    else
                        updateStatusIndicatorText(`胜利!`);
                    triggerConfetti();
                    document.getElementById('exportImageBtn').style.display = 'inline-block';
                    document.getElementById('shareLevelBtn').style.display = 'inline-block';
                    if (sumzleEasterEggActivated && !quarkModeActive && !titleFallAnimation.active) {
                       if (!titleFallAnimation.originalComputedTop) {
                           titleFallAnimation.originalComputedTop = getComputedStyle(headerTitleElement).top;
                       }
                        startTitleFallAnimation(headerTitleElement, 'sumzle-fall', ()=>{
                            triggerQuarkModeAfterFall();
                        });
                    }
                } else {
                    playSound('failure');
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'lose');
                    if (!isCustomLevel || isViewingHistoryState) {
                        stats.total.gamesPlayed++;
                        stats.total.currentStreak = 0;
                        stats.byDifficulty[currentDifficulty].gamesPlayed++;
                        saveStats();
                    }
                    if (statusString === 'SURRENDERED')
                        finalMessage = `已放弃。答案: ${displayTargetEquation} 🙁`;
                     else if (statusString === 'LOST_SUDDEN_DEATH')
                        finalMessage = `时间到! 答案: ${displayTargetEquation} 💀`;
                    else
                        finalMessage = `游戏结束! 答案: ${displayTargetEquation} 🙁`;
                    if (elapsedSeconds > 0)
                        updateStatusIndicatorText(`失败。用时: ${formatTime(elapsedSeconds)}`);
                    else
                        updateStatusIndicatorText(`失败`);
                    document.getElementById('exportImageBtn').style.display = 'none';
                    document.getElementById('shareLevelBtn').style.display = 'inline-block';
                }
                showMessage(finalMessage, statusString === 'SURRENDERED' ? 3e3 : 4e3);
                updateStatsDisplay();
                updateBackgroundStyle();
                
                const historyRecordDelay = (COLS > 0 ? COLS * 100 : currentCol * 100) + 500;
                const modalDelay = historyRecordDelay + 100;

                setTimeout(() => {
                    recordGameInHistory(isWin, statusString);
                }, historyRecordDelay);

                setTimeout(() => showModal('gameOverModal', isWin), modalDelay);
            }
            function checkGuess() {
                let guessChars = guessedEquation.slice(0, currentCol); 
                let actualTargetEquationString = targetEquation;
                let targetCharsCopy = [...actualTargetEquationString]; 

                const resultStates = Array(currentCol).fill('absent'); 
                
                if (debugSettings.misleadingFeedbackRate > 0 && Math.random() * 100 < debugSettings.misleadingFeedbackRate) {
                    for (let i = 0; i < currentCol; i++) {
                        const rand = Math.random();
                        if (rand < 0.33) resultStates[i] = 'correct';
                        else if (rand < 0.66) resultStates[i] = 'present';
                        else resultStates[i] = 'absent';
                    }
                } else {
                    for (let i = 0; i < currentCol; i++) {
                        if (guessChars[i] === targetCharsCopy[i]) { 
                            resultStates[i] = 'correct';
                            targetCharsCopy[i] = null; 
                        }
                    }
                    for (let i = 0; i < currentCol; i++) {
                        if (resultStates[i] !== 'correct') {
                            const indexInTarget = targetCharsCopy.indexOf(guessChars[i]);
                            if (indexInTarget !== -1) {
                                resultStates[i] = 'present';
                                targetCharsCopy[indexInTarget] = null; 
                            }
                        }
                    }
                }


                const boardRow = document.querySelector(`.row:nth-child(${currentRow + 1})`);
                if (boardRow) {
                    const tiles = boardRow.children;
                    const displayColsForFlip = debugSettings.unknownLengthMode ? currentCol : COLS;

                    for (let i = 0; i < displayColsForFlip; i++) { 
                        const tile = tiles[i];
                        if (tile) { 
                             setTimeout(()=>{
                                tile.classList.add('flip-reveal');
                                setTimeout(()=>{
                                    tile.classList.remove('absent', 'present', 'correct', 'filled', 'unknown-length');
                                    if (i < resultStates.length) { 
                                        tile.classList.add(resultStates[i]);
                                    } else {
                                        tile.classList.add('absent'); 
                                    }
                                    tile.style.borderColor = '';
                                } , 350);
                            } , i * 100);
                        }
                    }
                }
                updateKeyboardColors(guessChars, resultStates.slice(0, guessChars.length));
            }
            function updateKeyboardColors(chars, results) {
                if (debugSettings.blindMode) return;

                for (let i = 0; i < chars.length; i++) {
                    const char = chars[i]
                      , result = results[i];
                    if (!char)
                        continue;
                    document.querySelectorAll(`.key[data-char="${char}"]`).forEach(key=>{
                        const kcl = key.classList;
                        if (char === '>' && result === 'absent' && !kcl.contains('correct') && !kcl.contains('present')) {
                            kcl.add('disabled-permanently');
                            kcl.remove('present', 'correct', 'absent');
                            return;
                        }
                        if (kcl.contains('disabled-permanently'))
                            return;
                        if (result === 'correct') {
                            kcl.remove('present', 'absent');
                            kcl.add('correct');
                        } else if (result === 'present' && !kcl.contains('correct')) {
                            kcl.remove('absent');
                            kcl.add('present');
                        } else if (result === 'absent' && !kcl.contains('correct') && !kcl.contains('present')) {
                            kcl.add('absent');
                             if (debugSettings.grayKeysUnclickable) {
                                kcl.add('disabled-permanently');
                            }
                        }
                    }
                    );
                }
            }
            function showMessage(text, duration=2e3) {
                const msgEl = document.getElementById('message');
                clearTimeout(messageTimeout);
                msgEl.textContent = text;
                msgEl.classList.remove('show-message');
                void msgEl.offsetWidth;
                msgEl.classList.add('show-message');
                messageTimeout = setTimeout(()=>msgEl.classList.remove('show-message'), duration);
            }
            function showModal(modalId, isWinArgForGameOver) {
                const modal = document.getElementById(modalId);
                if (!modal)
                    return;
                if (modalId === 'gameOverModal') {
                    const title = document.getElementById('gameOverTitle')
                      , msg = document.getElementById('gameOverMessage')
                      , displayTargetEquation = targetEquation.replace(/\*/g, '×').replace(/\//g, '÷');
                    if (isWinArgForGameOver) {
                        title.innerHTML = '🏆 恭喜！🏆';
                        msg.textContent = `你用了 ${currentRow + 1} 次猜中: ${displayTargetEquation}`;
                    } else {
                        title.innerHTML = '💔 游戏结束 💔';
                        msg.textContent = `正确答案: ${displayTargetEquation}`;
                    }
                } else if (modalId === 'debugModal') {
                     setHeaderTitleState('debug'); 
                }
                modal.style.display = 'flex';
                void modal.offsetWidth;
                modal.classList.add('show');
            }
            function hideModal(modalId) {
                const modal = document.getElementById(modalId);
                if (!modal || !modal.classList.contains('show'))
                    return;
                modal.classList.remove('show');
                setTimeout(()=>modal.style.display = 'none', 350);
                if (modalId === 'debugModal') {
                    const currentHeaderStateClass = Array.from(headerTitleElement.classList).find(c=>c.startsWith('state-'));
                    const currentHeaderState = currentHeaderStateClass ? currentHeaderStateClass.replace('state-', '') : 'idle';

                    if(quarkModeActive){
                        if (currentHeaderState === 'win' || currentHeaderState === 'lose') {
                            setHeaderTitleState(currentHeaderState);
                        } else {
                            setHeaderTitleState('quark');
                        }
                    } else {
                         if (currentHeaderState === 'win' || currentHeaderState === 'lose') {
                            setHeaderTitleState(currentHeaderState);
                        } else {
                             setHeaderTitleState('idle');
                        }
                    }
                }
            }
            function saveStats() {
                localStorage.setItem('sumzleStats', JSON.stringify(stats));
            }
            function saveDifficulty() {
                localStorage.setItem('sumzleDifficulty', currentDifficulty);
            }
            document.getElementById('newGameBtn').addEventListener('click', ()=>{
                hideModal('gameOverModal');
                resetGame();
            }
            );
            restartBtn.addEventListener('click', handleRestartOrExitView);
            function handleRestartOrExitView() {
                if (isViewingHistoryState)
                    exitHistoryView();
                else {
                    if (gameActive && (currentRow > 0 || currentCol > 0 || isCustomLevel))
                        showModal('surrenderModal');
                    else
                        resetGame();
                }
            }
            document.getElementById('confirmSurrenderBtn').addEventListener('click', ()=>{
                hideModal('surrenderModal');
                handleEndGame(false, 'SURRENDERED');
            }
            );
            document.getElementById('cancelSurrenderBtn').addEventListener('click', ()=>hideModal('surrenderModal'));
            const menuToggleBtn = document.getElementById('menuToggleBtn')
              , headerButtonsGroup = document.getElementById('headerButtonsGroup');
            if (menuToggleBtn)
                menuToggleBtn.addEventListener('click', event=>{
                    event.stopPropagation();
                    headerButtonsGroup.classList.toggle('show-menu');
                    menuToggleBtn.classList.toggle('active');
                }
                );
            document.addEventListener('click', event=>{
                if (headerButtonsGroup && headerButtonsGroup.classList.contains('show-menu') && !headerButtonsGroup.contains(event.target) && event.target !== menuToggleBtn) {
                    headerButtonsGroup.classList.remove('show-menu');
                    if (menuToggleBtn)
                        menuToggleBtn.classList.remove('active');
                }
                if (activeTooltipKey && isTouchDevice() && event.target !== activeTooltipKey && !activeTooltipKey.contains(event.target)) {
                    clearTimeout(activeTooltipTimeout);
                    activeTooltipKey.classList.remove('show-tooltip');
                    activeTooltipKey = null;
                }
            }
            );
            document.getElementById('settingsBtn').addEventListener('click', ()=>{
                showModal('settingsModal');
            }
            );
            document.getElementById('closeSettingsBtn').addEventListener('click', ()=>hideModal('settingsModal'));
            document.getElementById('statsBtn').addEventListener('click', ()=>{
                updateStatsDisplay();
                showModal('statsModal');
            }
            );
            document.getElementById('closeStatsBtn').addEventListener('click', ()=>hideModal('statsModal'));
            document.getElementById('clearStatsBtn').addEventListener('click', clearStatistics);
            document.querySelectorAll('.difficulty-btn').forEach(btn=>{
                btn.addEventListener('click', ()=>{
                    isCustomLevel = false;
                    currentDifficulty = btn.dataset.difficulty;
                    ROWS = difficultySetting[currentDifficulty].attempts;
                    saveDifficulty();
                    resetGame();
                    hideModal('settingsModal');
                }
                );
            }
            );
            document.addEventListener('keydown', e=>{
                let activeModalId = null;
                document.querySelectorAll('.modal.show').forEach(m=>activeModalId = m.id);
                if (e.key === 'Escape' && activeModalId) {
                    e.preventDefault();
                    if (activeModalId === 'debugModal' && document.activeElement.tagName === 'TEXTAREA' && document.activeElement.closest('.debug-option')) {
                       
                    } else {
                        hideModal(activeModalId);
                    }
                    return;
                }
                const isTypingInModalInput = (activeModalId === 'loadLevelModal' && document.activeElement === document.getElementById('levelCodeInput')) ||
                                        (activeModalId === 'debugModal' && (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.type === 'number' || document.activeElement.type === 'text' || document.activeElement.type === 'color'));

                if (activeModalId && !isTypingInModalInput && e.key !== 'Enter')
                    return;
                 if (activeModalId && isTypingInModalInput && e.key === 'Enter' && document.activeElement.tagName === 'TEXTAREA') {
                 } else if (validChars.includes(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey && e.key.length === 1) {
                    if (!activeModalId || (activeModalId && !isTypingInModalInput)) {
                        e.preventDefault();
                        const keyElement = document.querySelector(`.key[data-char="${e.key}"]`);
                        handleKeyPress(e.key, keyElement);
                    }
                } else if (e.key === 'Backspace') {
                     if (!activeModalId || (activeModalId && !isTypingInModalInput)) {
                        e.preventDefault();
                        handleDelete();
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (activeModalId === 'gameOverModal')
                        document.getElementById('newGameBtn').click();
                    else if (activeModalId === 'settingsModal')
                        document.getElementById('closeSettingsBtn').click();
                    else if (activeModalId === 'statsModal')
                        document.getElementById('closeStatsBtn').click();
                    else if (activeModalId === 'loadLevelModal' && !isTypingInModalInput)
                        document.getElementById('submitLoadLevelBtn').click();
                    else if (activeModalId === 'surrenderModal')
                        document.getElementById('confirmSurrenderBtn').click();
                    else if (activeModalId === 'confirmClearStatsModal')
                        document.getElementById('executeClearStatsBtn').click();
                    else if (activeModalId === 'historyModal')
                        document.getElementById('closeHistoryModalBtn').click();
                    else if (activeModalId === 'confirmClearHistoryModal')
                        document.getElementById('executeClearHistoryBtn').click();
                    else if (activeModalId === 'confirmNukeModal')
                        document.getElementById('executeNukeBtn').click();
                    else if (activeModalId === 'debugModal' && !isTypingInModalInput)
                        document.getElementById('applyDebugSettingsBtn').click();
                    else if (gameActive && !isViewingHistoryState)
                        handleSubmit();
                }
            }
            );
            function captureFinalBoardRender() {
                const render = [];
                const rowsToCapture = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.finalBoardRender.length : gameActive ? currentRow + 1 : ROWS;
                const colsToCapture = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.targetEquation.length : COLS > 0 ? COLS : (debugSettings.unknownLengthMode ? guessedEquation.slice(0, currentCol).join('').length : targetEquation.length);


                for (let r = 0; r < rowsToCapture; r++) {
                    if (r >= ROWS)
                        break;
                    const rowRender = []
                      , rowElement = document.querySelector(`.board .row:nth-child(${r + 1})`);
                    if (!rowElement) {
                        render.push(Array(colsToCapture).fill(null));
                        continue;
                    }
                    for (let c = 0; c < colsToCapture; c++) {
                        const tile = rowElement.children[c];
                        if (tile) {
                            let tileClassList = Array.from(tile.classList);
                            tileClassList = tileClassList.filter(cls => cls !== 'unknown-length');
                            rowRender.push({
                                text: tile.textContent,
                                classList: tileClassList
                            });
                        } else {
                            rowRender.push(null);
                        }
                    }
                    render.push(rowRender);
                }
                return render;
            }
            function captureKeyboardState() {
                const keyboardState = {};
                document.querySelectorAll('.key[data-char]').forEach(key=>{
                    const char = key.dataset.char;
                    if (key.classList.contains('correct'))
                        keyboardState[char] = 'correct';
                    else if (key.classList.contains('present'))
                        keyboardState[char] = 'present';
                    else if (key.classList.contains('absent'))
                        keyboardState[char] = 'absent';
                    else if (key.classList.contains('disabled-permanently'))
                        keyboardState[char] = 'disabled-permanently';
                }
                );
                return keyboardState;
            }
            function recordGameInHistory(isWin, finalStatus) {
                const finalBoardRender = captureFinalBoardRender();
                const keyboardState = captureKeyboardState();
                
                let recordedAttempts;
                if (finalStatus === 'LOST' || finalStatus === 'LOST_SUDDEN_DEATH') { 
                    recordedAttempts = ROWS;
                } else if (isWin) { 
                    recordedAttempts = currentRow + 1; 
                } else if (finalStatus === 'SURRENDERED') { 
                    recordedAttempts = currentRow; 
                } else if (finalStatus === ABANDONED_STATUS) {
                    recordedAttempts = currentRow;
                } else { 
                    recordedAttempts = currentRow; 
                }

                const historyEntry = {
                    id: Date.now().toString(36) + Math.random().toString(36).substring(2),
                    timestamp: Date.now(),
                    targetEquation: targetEquation,
                    difficulty: currentDifficulty,
                    status: finalStatus,
                    attemptsMade: recordedAttempts,
                    timeTaken: elapsedSeconds > 0 ? elapsedSeconds : null,
                    finalBoardRender: finalBoardRender,
                    keyboardState: keyboardState,
                    guessedRows: [...guessedEquationsHistory]
                };
                let gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];
                gameHistory.unshift(historyEntry);
                if (gameHistory.length > 50)
                    gameHistory.length = 50;
                localStorage.setItem('sumzleGameHistory', JSON.stringify(gameHistory));
            }
            function disableKeyboardForView() {
                document.querySelectorAll('.key').forEach(key=>{
                    if (key.dataset.char || key.textContent === '提交' || key.textContent === 'AC' || key.textContent === '删除')
                        key.classList.add('disabled-view-mode');
                }
                );
                document.getElementById('keyboard').classList.add('disabled-input');
            }
            function enableKeyboardForPlay() {
                document.querySelectorAll('.key.disabled-view-mode').forEach(key=>key.classList.remove('disabled-view-mode'));
                document.getElementById('keyboard').classList.remove('disabled-input');
            }
            function applyHistoricalBoardState(item) {
                item.finalBoardRender.forEach((rowRenderData,r)=>{
                    if (r >= ROWS)
                        return;
                    const displayCols = item.targetEquation.length; 
                    rowRenderData.forEach((tileRenderData,c)=>{
                         if (c >= displayCols) return; 

                        const tileElement = document.getElementById(`tile-${r}-${c}`);
                        if (tileElement && tileRenderData) {
                            tileElement.textContent = tileRenderData.text;
                            tileElement.className = 'tile'; 
                            tileRenderData.classList.forEach(cls=>{
                                if (cls !== 'tile-new-game-appear' && cls !== 'pop' && cls !== 'unknown-length')
                                    tileElement.classList.add(cls);
                            }
                            );
                        }
                    }
                    );
                }
                );
                resetKeyboardColors();
                Object.entries(item.keyboardState).forEach(([char,state])=>{
                    document.querySelectorAll(`.key[data-char="${char}"]`).forEach(key=>{
                        if (state) {
                            key.classList.remove('correct', 'present', 'absent', 'disabled-permanently');
                            key.classList.add(state);
                        }
                    }
                    );
                }
                );
            }
            function exitHistoryView() {
                isViewingHistoryState = false;
                viewingHistoryItem = null;
                restartBtn.title = "重新开始/投降";
                restartBtn.innerHTML = '🔄';
                enableKeyboardForPlay();
                document.getElementById('exportImageBtn').style.display = 'none';
                document.getElementById('shareLevelBtn').style.display = 'none';
                resetGame();
            }
            function loadHistoryItemState(item) {
                isViewingHistoryState = true;
                viewingHistoryItem = item;
                gameActive = false;

                stopLiveStatusUpdates();


                currentDifficulty = item.difficulty;
                targetEquation = item.targetEquation;
                ROWS = difficultySetting[currentDifficulty].attempts;
                COLS = targetEquation.length; 
                
                const originalUnknownLengthMode = debugSettings.unknownLengthMode;
                debugSettings.unknownLengthMode = false; 
                initBoard(); 
                debugSettings.unknownLengthMode = originalUnknownLengthMode; 

                initKeyboard();
                applyHistoricalBoardState(item);
                currentRow = item.attemptsMade - 1; 
                if(item.status === ABANDONED_STATUS) {
                    currentRow = item.attemptsMade; 
                } else if (item.status === 'WON' || item.status === 'LOST' || item.status === 'LOST_SUDDEN_DEATH' || item.status === 'SURRENDERED') {
                     currentRow = item.attemptsMade > 0 ? item.attemptsMade -1 : 0;
                }


                updateStatusIndicatorText(`${item.status === 'WON' ? '查看胜利' : item.status === 'LOST' ? '查看失败' : item.status === 'LOST_SUDDEN_DEATH' ? '查看猝死' :  item.status === 'SURRENDERED' ? '查看放弃' : item.status === ABANDONED_STATUS ? '查看离开记录' : '查看记录'} (${difficultySetting[item.difficulty].name})${item.timeTaken ? ' - 用时: ' + formatTime(item.timeTaken) : ''}`);
                disableKeyboardForView();
                if (item.status === 'WON')
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'win');
                else if (item.status === 'LOST' || item.status === 'LOST_SUDDEN_DEATH' || item.status === 'SURRENDERED' || item.status === ABANDONED_STATUS)
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'lose');
                else
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'history');
                restartBtn.title = "关闭查看";
                restartBtn.innerHTML = '❌';
                document.getElementById('exportImageBtn').style.display = 'inline-block';
                document.getElementById('shareLevelBtn').style.display = 'inline-block';
                hideModal('historyModal');
                updateBackgroundStyle();
            }
            function displayHistory() {
                const historyListContainer = document.getElementById('historyListContainer')
                  , noHistoryMsg = document.getElementById('noHistoryMessage')
                  , clearHistoryBtn = document.getElementById('clearHistoryBtn');
                historyListContainer.innerHTML = '';
                const gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];
                if (gameHistory.length === 0) {
                    noHistoryMsg.style.display = 'block';
                    clearHistoryBtn.style.display = 'none';
                    return;
                }
                noHistoryMsg.style.display = 'none';
                clearHistoryBtn.style.display = 'inline-block';
                gameHistory.forEach(item=>{
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'history-item';
                    itemDiv.dataset.historyId = item.id;
                    const statusClass = item.status ? item.status.toLowerCase() : 'unknown';
                    let statusText = '未知';
                    if (item.status === 'WON') statusText = '胜利';
                    else if (item.status === 'LOST') statusText = '失败';
                    else if (item.status === 'LOST_SUDDEN_DEATH') statusText = '猝死';
                    else if (item.status === 'SURRENDERED') statusText = '放弃';
                    else if (item.status === ABANDONED_STATUS) statusText = '已离开';

                    itemDiv.innerHTML = `<div class="history-item-preview"><span class="history-equation">${item.targetEquation.replace(/\*/g, '×').replace(/\//g, '÷')}</span><span class="history-status ${statusClass}">${statusText}</span></div><div class="history-item-details"><span>${difficultySetting[item.difficulty].name}</span> | <span>${new Date(item.timestamp).toLocaleDateString()} ${new Date(item.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit'
                    })}</span>${item.timeTaken !== null ? ` | <span>用时: ${formatTime(item.timeTaken)}</span>` : ''}<span>(${item.attemptsMade} / ${difficultySetting[item.difficulty].attempts} 次尝试)</span></div><div class="history-item-actions"><button class="history-replay-btn secondary-btn">重玩</button><button class="history-view-state-btn primary-btn">查看</button><button class="history-delete-btn danger-btn">删除</button></div>`;
                    itemDiv.querySelector('.history-replay-btn').addEventListener('click', ()=>{
                        isCustomLevel = true;
                        startGame(item.targetEquation, item.difficulty);
                        hideModal('historyModal');
                    }
                    );
                    itemDiv.querySelector('.history-view-state-btn').addEventListener('click', ()=>loadHistoryItemState(item));
                    itemDiv.querySelector('.history-delete-btn').addEventListener('click', ()=>{
                        let updatedHistory = gameHistory.filter(h=>h.id !== item.id);
                        localStorage.setItem('sumzleGameHistory', JSON.stringify(updatedHistory));
                        displayHistory();
                    }
                    );
                    historyListContainer.appendChild(itemDiv);
                }
                );
            }
            document.getElementById('historyBtn').addEventListener('click', ()=>{
                displayHistory();
                showModal('historyModal');
            }
            );
            document.getElementById('closeHistoryModalBtn').addEventListener('click', ()=>hideModal('historyModal'));
            document.getElementById('clearHistoryBtn').addEventListener('click', ()=>showModal('confirmClearHistoryModal'));
            document.getElementById('executeClearHistoryBtn').addEventListener('click', ()=>{
                localStorage.removeItem('sumzleGameHistory');
                displayHistory();
                hideModal('confirmClearHistoryModal');
                showMessage("游戏历史已清空");
            }
            );
            document.getElementById('cancelClearHistoryBtn').addEventListener('click', ()=>hideModal('confirmClearHistoryModal'));
            
            function exportGameImage() {
                const gameBoardElement = document.getElementById('board');
                if (!gameBoardElement) { 
                    showMessage("错误：找不到游戏板元素。", 2000);
                    return; 
                }

                const originalTiles = Array.from(gameBoardElement.querySelectorAll('.tile'));
                
                let numColsForExport;
                let gameDifficultyForExport = currentDifficulty;

                if (isViewingHistoryState && viewingHistoryItem) {
                    numColsForExport = viewingHistoryItem.targetEquation.length;
                    gameDifficultyForExport = viewingHistoryItem.difficulty;
                } else {
                    numColsForExport = COLS > 0 ? COLS : (guessedEquation.join('').length > 0 ? guessedEquation.join('').length : DEFAULT_MAX_EQUATION_LENGTH) ;
                    if (debugSettings.unknownLengthMode) numColsForExport = targetEquation.length; 
                }

                if (!numColsForExport || numColsForExport <= 0) {
                    const firstRow = gameBoardElement.querySelector('.row');
                    if (firstRow && firstRow.children.length > 0) {
                        numColsForExport = firstRow.children.length;
                    } else {
                        showMessage("无法导出：棋盘列数未知。", 2000);
                        return;
                    }
                }
                
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-99999px'; 
                tempContainer.style.top = '-99999px';
                tempContainer.style.padding = '20px';
                tempContainer.style.backgroundColor = getComputedStyle(document.body).backgroundColor;
                tempContainer.style.width = 'max-content'; 

                const headerElement = document.querySelector('header');
                const titleElement = headerElement.querySelector('.header-title');
                const titleClone = document.createElement('div');
                const computedOriginalTitleStyle = getComputedStyle(titleElement);
                titleClone.style.position = 'static';
                titleClone.style.transform = 'none';
                titleClone.style.display = 'block';
                titleClone.style.textAlign = 'center';
                titleClone.style.width = '100%';
                titleClone.style.marginBottom = '25px';
                titleClone.style.fontSize = computedOriginalTitleStyle.fontSize;
                titleClone.style.fontWeight = computedOriginalTitleStyle.fontWeight;
                titleClone.style.fontFamily = computedOriginalTitleStyle.fontFamily;
                titleClone.style.letterSpacing = computedOriginalTitleStyle.letterSpacing;
                let actualTextContent = "";
                Array.from(titleElement.querySelectorAll('.title-char')).forEach(span => {
                    actualTextContent += span.textContent;
                });
                titleClone.textContent = actualTextContent || "SUMZLE";
                titleClone.style.color = '#FF69B4'; 
                titleClone.style.webkitBackgroundClip = 'unset';
                titleClone.style.backgroundClip = 'unset';
                titleClone.style.backgroundImage = 'none';
                titleClone.style.webkitTextFillColor = '#FF69B4'; 
                titleClone.style.animation = 'none';

                const boardClone = gameBoardElement.cloneNode(true);
                boardClone.id = 'boardCloneForExport';
                boardClone.style.display = 'grid'; 
                boardClone.style.width = 'max-content'; 
                boardClone.style.overflow = 'visible';
                boardClone.style.maxWidth = 'none';   

                const clonedTiles = Array.from(boardClone.querySelectorAll('.tile'));
                clonedTiles.forEach((clonedTile, index) => {
                    const originalTile = originalTiles[index]; 
                    if (originalTile) { 
                        const computedStyle = window.getComputedStyle(originalTile);
                        clonedTile.style.backgroundColor = computedStyle.backgroundColor;
                        clonedTile.style.color = computedStyle.color;
                        clonedTile.style.borderColor = computedStyle.borderColor;
                        clonedTile.style.borderStyle = computedStyle.borderStyle;
                        clonedTile.style.borderWidth = computedStyle.borderWidth;
                        clonedTile.textContent = originalTile.textContent;
                         if (index >= numColsForExport * ROWS) { 
                            clonedTile.style.display = 'none';
                        }
                    }
                    clonedTile.style.transform = 'none';
                    clonedTile.style.animation = 'none';
                    clonedTile.classList.remove('win-dance', 'flip-reveal', 'pop', 'filled', 'tile-new-game-appear', 'tile-cleared-animation', 'unknown-length');
                    if (originalTile) {
                        if (originalTile.classList.contains('correct')) clonedTile.classList.add('correct');
                        else if (originalTile.classList.contains('present')) clonedTile.classList.add('present');
                        else if (originalTile.classList.contains('absent')) clonedTile.classList.add('absent');
                    }
                });
                 Array.from(boardClone.querySelectorAll('.row')).forEach(rowNode => {
                    rowNode.style.gridTemplateColumns = `repeat(${numColsForExport}, 1fr)`;
                 });

                
                const exportMessage = document.createElement('p');
                let difficultyText, attemptsInfo;
                difficultyText = difficultySetting[gameDifficultyForExport].name;
                if (isViewingHistoryState && viewingHistoryItem) {
                    const itemStatusText = viewingHistoryItem.status === 'WON' ? '胜利' :
                                           viewingHistoryItem.status === 'LOST' ? '失败' : 
                                           viewingHistoryItem.status === 'LOST_SUDDEN_DEATH' ? '猝死' :
                                           viewingHistoryItem.status === 'SURRENDERED' ? '放弃' :
                                           viewingHistoryItem.status === ABANDONED_STATUS ? '离开' : '记录';
                    attemptsInfo = `${viewingHistoryItem.attemptsMade}/${difficultySetting[viewingHistoryItem.difficulty].attempts} (${itemStatusText})`;
                    if (viewingHistoryItem.timeTaken) {
                        attemptsInfo += ` - 用时: ${formatTime(viewingHistoryItem.timeTaken)}`;
                    }
                } else {
                    let finalAttemptsCount;
                    if (!gameActive) { 
                        finalAttemptsCount = guessedEquationsHistory.length; 
                         if (finalAttemptsCount === 0 && targetEquation === guessedEquation.join('')) {
                            finalAttemptsCount = 1;
                        }
                    } else { 
                        finalAttemptsCount = currentRow;
                        if (currentCol > 0 || guessedEquation.join('').length > 0) {
                            finalAttemptsCount = currentRow + 1;
                        }
                         if (finalAttemptsCount === 0 && guessedEquationsHistory.length > 0) {
                           finalAttemptsCount = guessedEquationsHistory.length;
                        }
                    }
                    attemptsInfo = `${finalAttemptsCount}/${difficultySetting[gameDifficultyForExport].attempts} 尝试`;
                    if (elapsedSeconds > 0 && !gameActive) {
                        attemptsInfo += ` - 用时: ${formatTime(elapsedSeconds)}`;
                    }
                }
                exportMessage.textContent = `Sumzle ${difficultyText} - ${attemptsInfo}`;
                exportMessage.style.textAlign = 'center';
                exportMessage.style.marginTop = '25px';
                exportMessage.style.fontWeight = 'bold';
                exportMessage.style.fontSize = '1rem';
                exportMessage.style.color = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();

                tempContainer.appendChild(titleClone);
                tempContainer.appendChild(boardClone);
                tempContainer.appendChild(exportMessage);
                document.body.appendChild(tempContainer);

                
                const boardComputedStyle = getComputedStyle(boardClone);
                const boardGap = parseFloat(boardComputedStyle.gap) || 6; 
                const firstTile = clonedTiles.length > 0 ? clonedTiles[0] : null;
                let tileWidth = 50; 
                if (firstTile) {
                    const firstTileStyle = getComputedStyle(firstTile);
                    tileWidth = parseFloat(firstTileStyle.width) + 
                                parseFloat(firstTileStyle.borderLeftWidth) + 
                                parseFloat(firstTileStyle.borderRightWidth);
                }
                
                let calculatedBoardWidth = (numColsForExport * tileWidth) + 
                                           Math.max(0, numColsForExport - 1) * boardGap +
                                           parseFloat(boardComputedStyle.paddingLeft) + 
                                           parseFloat(boardComputedStyle.paddingRight);
                
                boardClone.style.width = calculatedBoardWidth + 'px';
                
                const tempContainerPadding = parseFloat(getComputedStyle(tempContainer).paddingLeft) + parseFloat(getComputedStyle(tempContainer).paddingRight);
                tempContainer.style.width = (boardClone.offsetWidth + tempContainerPadding) + 'px';


                setTimeout(() => {
                    if (typeof html2canvas === 'undefined') {
                        showMessage("图片导出功能不可用 (库未加载)。", 3000);
                        if (tempContainer.parentElement) document.body.removeChild(tempContainer);
                        return;
                    }
                    try {
                        const captureWidth = tempContainer.offsetWidth;
                        const captureHeight = tempContainer.offsetHeight;

                        html2canvas(tempContainer, {
                            backgroundColor: tempContainer.style.backgroundColor,
                            useCORS: true,
                            scale: window.devicePixelRatio * 1.2,
                            width: captureWidth,
                            height: captureHeight,
                            windowWidth: captureWidth,
                            windowHeight: captureHeight,
                            logging: false,
                            onclone: (clonedDocument) => {
                                const clonedBoardInDoc = clonedDocument.getElementById('boardCloneForExport');
                                if (clonedBoardInDoc) {
                                    clonedBoardInDoc.style.width = boardClone.style.width; 
                                    clonedBoardInDoc.querySelectorAll('.tile').forEach(tile => {
                                        tile.style.animation = 'none !important';
                                        tile.style.transform = 'none !important';
                                    });
                                }
                            }
                        }).then(canvas => {
                            const image = canvas.toDataURL("image/png");
                            const link = document.createElement('a');
                            link.href = image;
                            link.download = `Sumzle_Game_${new Date().toISOString().slice(0, 10)}.png`;
                            link.click();
                            showMessage("图片已导出!", 2000);
                        }).catch(err => {
                            showMessage("导出图片失败. 查看控制台获取详情.", 3000);
                        }).finally(() => {
                            if (tempContainer.parentElement) document.body.removeChild(tempContainer);
                        });
                    } catch (e) {
                        showMessage("导出图片时出错 (库错误)。", 3000);
                        if (tempContainer.parentElement) document.body.removeChild(tempContainer);
                    }
                }, 150); 
            }


            document.getElementById('exportImageBtn').addEventListener('click', ()=>{
                exportGameImage();
            }
            );
            function fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.top = "0";
                textArea.style.left = "0";
                textArea.style.width = "2em";
                textArea.style.height = "2em";
                textArea.style.padding = "0";
                textArea.style.border = "none";
                textArea.style.outline = "none";
                textArea.style.boxShadow = "none";
                textArea.style.background = "transparent";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful)
                        showMessage("关卡代码已复制!");
                    else
                        showMessage("复制失败.");
                } catch (err) {
                    showMessage("复制失败: " + err);
                }
                document.body.removeChild(textArea);
            }
            document.getElementById('shareLevelBtn').addEventListener('click', ()=>{
                const encoded = encodeLevel(targetEquation, currentDifficulty);
                if (encoded) {
                    if (navigator.clipboard && navigator.clipboard.writeText)
                        navigator.clipboard.writeText(encoded).then(()=>showMessage("关卡代码已复制!")).catch(err=>{
                            fallbackCopyTextToClipboard(encoded);
                        }
                        );
                    else
                        fallbackCopyTextToClipboard(encoded);
                } else
                    showMessage("生成分享代码失败!");
            }
            );
            document.getElementById('loadLevelBtn').addEventListener('click', ()=>{
                showModal('loadLevelModal');
            }
            );
            document.getElementById('closeLoadLevelModalBtn').addEventListener('click', ()=>{
                document.getElementById('levelCodeInput').value = '';
                hideModal('loadLevelModal');
            }
            );
            document.getElementById('submitLoadLevelBtn').addEventListener('click', ()=>{
                const code = document.getElementById('levelCodeInput').value;
                if (code) {
                    const decodedData = decodeLevel(code.trim());
                    if (decodedData && decodedData.equation.length >= MIN_EQUATION_LENGTH && decodedData.equation.length <= DEFAULT_MAX_EQUATION_LENGTH && isValidEquation(decodedData.equation.split(''), true)) {
                        isCustomLevel = true;
                        startGame(decodedData.equation, decodedData.difficulty);
                        saveDifficulty();
                        hideModal('loadLevelModal');
                        document.getElementById('levelCodeInput').value = '';
                        showMessage(`已载入 ${difficultySetting[decodedData.difficulty].name} 难度分享关卡!`);
                    } else
                        showMessage("无效或已损坏的关卡代码。");
                }
            }
            );

            function animateTitleFall() {
                if (!titleFallAnimation.active) return;
                const el = titleFallAnimation.element;
                titleFallAnimation.vy += titleFallAnimation.gravity;
                titleFallAnimation.y += titleFallAnimation.vy;
                el.style.top = `${titleFallAnimation.y}px`;
                el.style.transform = 'translateX(-50%)';

                if (titleFallAnimation.type === 'sumzle-fall' && titleFallAnimation.y > window.innerHeight + el.offsetHeight) {
                    titleFallAnimation.active = false;
                    el.style.opacity = '0';
                    if (titleFallAnimation.onComplete) titleFallAnimation.onComplete();
                } else if (titleFallAnimation.type === 'quark-fall' && titleFallAnimation.y >= titleFallAnimation.targetY) {
                    titleFallAnimation.active = false;
                    el.style.top = `${titleFallAnimation.targetY}px`;
                    el.style.opacity = '1';
                     if (titleFallAnimation.originalComputedTransition) {
                         el.style.transition = titleFallAnimation.originalComputedTransition;
                     } else {
                        el.style.transition = 'top .8s cubic-bezier(0.6, -0.28, 0.735, 0.045), opacity .5s ease-out';
                     }
                    if (titleFallAnimation.onComplete) titleFallAnimation.onComplete();
                }
                if (titleFallAnimation.active) {
                    requestAnimationFrame(animateTitleFall);
                }
            }

            function startTitleFallAnimation(element, type, onCompleteCallback) {
                if (!titleFallAnimation.originalComputedTransition) {
                    titleFallAnimation.originalComputedTransition = getComputedStyle(element).transition;
                    titleFallAnimation.originalComputedTop = getComputedStyle(element).top;
                }
                element.style.transition = 'none';

                titleFallAnimation.active = true;
                titleFallAnimation.element = element;
                titleFallAnimation.type = type;
                titleFallAnimation.onComplete = onCompleteCallback;

                const rect = element.getBoundingClientRect();
                const computedStyle = getComputedStyle(element);

                if (type === 'sumzle-fall') {
                    titleFallAnimation.y = parseFloat(computedStyle.top) || (rect.top + window.scrollY);
                    titleFallAnimation.vy = 0;
                    element.style.opacity = '1';
                } else if (type === 'quark-fall') {
                    titleFallAnimation.y = -(rect.height + 50); 
                    titleFallAnimation.vy = titleFallAnimation.initialVyForQuark;
                    titleFallAnimation.targetY = parseFloat(titleFallAnimation.originalComputedTop);
                    element.style.opacity = '0'; 
                }
                element.style.left = '50%';
                element.style.transform = 'translateX(-50%)';
                animateTitleFall();
            }

            function handleCombinedTitleClick() {
                if (titleFallAnimation.active) return;

                if (quarkModeActive) {
                    const currentText = Array.from(headerTitleElement.querySelectorAll('.title-char')).map(s => s.textContent).join('');
                    if (currentText === QUARK_TITLE_TEXT) {
                        quarkDebugClickCount++;
                        if (quarkDebugClickCount >= QUARK_DEBUG_CLICK_THRESHOLD) {
                            quarkDebugClickCount = 0; 
                            prepareAndShowDebugModal();
                        }
                    }
                } else if (!sumzleEasterEggActivated) {
                    sumzleTitleClickCount++;
                    if (sumzleTitleClickCount >= SUMZLE_CLICK_THRESHOLD) {
                        sumzleEasterEggActivated = true;
                         if (!titleFallAnimation.originalComputedTop) {
                             titleFallAnimation.originalComputedTop = getComputedStyle(headerTitleElement).top;
                         }
                        headerTitleElement.style.pointerEvents = 'none';
                        startTitleFallAnimation(headerTitleElement, 'sumzle-fall', ()=>{
                            triggerQuarkModeAfterFall();
                        });
                    }
                }
            }
            headerTitleElement.addEventListener('click', handleCombinedTitleClick);


            function triggerQuarkModeAfterFall() {
                if (!quarkModeActive) {
                    quarkModeActive = true;
                    setupTitleSpans(QUARK_TITLE_TEXT);
                    headerTitleElement.style.opacity = '0'; 
                    headerTitleElement.style.top = `-${headerTitleElement.offsetHeight + 50}px`;
                    headerTitleElement.style.transition = 'none';

                    requestAnimationFrame(()=>{
                        startTitleFallAnimation(headerTitleElement, 'quark-fall', ()=>{
                            headerTitleElement.style.pointerEvents = 'auto';
                            setHeaderTitleState('quark'); 
                        });
                    });
                }
            }

            function prepareAndShowDebugModal() {
                document.getElementById('debugCustomExpr').value = debugSettings.customExpression;
                document.getElementById('debugLockLength').value = debugSettings.lockedLength;
                document.getElementById('debugMaxGenAttempts').value = debugSettings.maxGenAttempts;
                document.getElementById('debugDisableMax').checked = debugSettings.disableMaxLength;
                document.getElementById('debugGeneratedExprDisplay').value = ""; 
                document.getElementById('debugBgParticles').value = debugSettings.customBgParticleCount;
                document.getElementById('debugPsychedelicBgToggle').checked = debugSettings.psychedelicBgActive;
                
                document.getElementById('debugUnknownLengthToggle').checked = debugSettings.unknownLengthMode;
                document.getElementById('debugOneTryModeToggle').checked = debugSettings.oneTryMode;
                document.getElementById('debugMirrorInputToggle').checked = debugSettings.mirrorInputMode;
                document.getElementById('debugRandomKeyboardLayoutToggle').checked = debugSettings.randomKeyboardLayout;
                document.getElementById('debugMisleadingFeedbackRate').value = debugSettings.misleadingFeedbackRate;
                document.getElementById('debugSuddenDeathTimerToggle').checked = debugSettings.suddenDeathTimer;
                document.getElementById('debugVanishingInkToggle').checked = debugSettings.vanishingInkMode;
                document.getElementById('debugGrayKeysUnclickableToggle').checked = debugSettings.grayKeysUnclickable;
                document.getElementById('debugCurrentTargetDisplay').value = targetEquation;


                showModal('debugModal');
            }
            
            document.getElementById('debugLogTargetBtn').addEventListener('click', () => {
                 console.log("Current Target Equation:", targetEquation);
                 showMessage("目标已记录到控制台", 1500);
            });

            document.getElementById('applyDebugSettingsBtn').addEventListener('click', () => {
                debugSettings.customExpression = document.getElementById('debugCustomExpr').value.trim();
                const lockLengthVal = parseInt(document.getElementById('debugLockLength').value);
                debugSettings.lockedLength = isNaN(lockLengthVal) || lockLengthVal < MIN_EQUATION_LENGTH ? 0 : lockLengthVal;
                if (lockLengthVal > 0 && lockLengthVal < MIN_EQUATION_LENGTH) {
                     showMessage(`调试: 锁定长度必须至少为 ${MIN_EQUATION_LENGTH}. 已重置为0.`, 2000);
                     document.getElementById('debugLockLength').value = 0;
                }
                
                const maxGenAttemptsVal = parseInt(document.getElementById('debugMaxGenAttempts').value);
                debugSettings.maxGenAttempts = isNaN(maxGenAttemptsVal) || maxGenAttemptsVal <= 0 ? 0 : maxGenAttemptsVal; 
                if (maxGenAttemptsVal > 0 && maxGenAttemptsVal < 10) { 
                    showMessage("调试: 生成尝试上限过低 (至少10). 将使用默认值.", 2000);
                    document.getElementById('debugMaxGenAttempts').value = 0;
                    debugSettings.maxGenAttempts = 0;
                }

                debugSettings.disableMaxLength = document.getElementById('debugDisableMax').checked;
                
                if (debugSettings.customExpression) {
                    debugSettings.useCustomExpressionForNextGame = true;
                } else {
                    debugSettings.useCustomExpressionForNextGame = false;
                }
                
                debugSettings.unknownLengthMode = document.getElementById('debugUnknownLengthToggle').checked;
                debugSettings.oneTryMode = document.getElementById('debugOneTryModeToggle').checked;
                debugSettings.mirrorInputMode = document.getElementById('debugMirrorInputToggle').checked;
                const oldRandomLayout = debugSettings.randomKeyboardLayout;
                debugSettings.randomKeyboardLayout = document.getElementById('debugRandomKeyboardLayoutToggle').checked;
                if(oldRandomLayout !== debugSettings.randomKeyboardLayout) initKeyboard(); 
                
                debugSettings.misleadingFeedbackRate = parseInt(document.getElementById('debugMisleadingFeedbackRate').value) || 0;
                if(debugSettings.misleadingFeedbackRate < 0 || debugSettings.misleadingFeedbackRate > 100) debugSettings.misleadingFeedbackRate = 0;
                document.getElementById('debugMisleadingFeedbackRate').value = debugSettings.misleadingFeedbackRate;

                debugSettings.suddenDeathTimer = document.getElementById('debugSuddenDeathTimerToggle').checked;
                debugSettings.vanishingInkMode = document.getElementById('debugVanishingInkToggle').checked;
                debugSettings.grayKeysUnclickable = document.getElementById('debugGrayKeysUnclickableToggle').checked;


                showMessage("调试设置已应用!", 1500);
                hideModal('debugModal');
            });

            document.getElementById('closeDebugModalBtn').addEventListener('click', () => {
                hideModal('debugModal');
            });

            document.getElementById('debugGenerateExprBtn').addEventListener('click', () => {
                const tempExpr = generateRandomEquation();
                document.getElementById('debugGeneratedExprDisplay').value = tempExpr;
            });

            document.getElementById('debugSoundKeypress').addEventListener('click', () => playSound('keyPress'));
            document.getElementById('debugSoundWin').addEventListener('click', () => playSound('success'));
            document.getElementById('debugSoundFail').addEventListener('click', () => playSound('failure'));
            document.getElementById('debugConfettiBtn').addEventListener('click', () => triggerConfetti());
            
            document.getElementById('debugThemeCycleBtn').addEventListener('click', () => {
                let count = 0;
                const interval = setInterval(() => {
                    toggleTheme();
                    count++;
                    if (count >= 6) clearInterval(interval);
                }, 300);
            });

            document.getElementById('debugApplyBgParticlesBtn').addEventListener('click', () => {
                const count = parseInt(document.getElementById('debugBgParticles').value);
                debugSettings.customBgParticleCount = isNaN(count) || count < 0 ? 0 : count;
                updateBackgroundStyle(); 
                showMessage(`背景粒子数已${debugSettings.customBgParticleCount > 0 ? '设为 ' + debugSettings.customBgParticleCount : '重置为默认'}`, 1500);
            });
            
            document.getElementById('debugPsychedelicBgToggle').addEventListener('change', (event) => {
                debugSettings.psychedelicBgActive = event.target.checked;
                updateBackgroundStyle(); 
            });
            
            document.getElementById('debugForceWinBtn').addEventListener('click', () => {
                handleEndGame(true, 'WON');
                hideModal('debugModal');
            });
            document.getElementById('debugForceLoseBtn').addEventListener('click', () => {
                handleEndGame(false, 'LOST');
                hideModal('debugModal');
            });
            document.getElementById('debugTriggerShakeBtn').addEventListener('click', () => {
                const currentRowEl = document.querySelector(`.board .row:nth-child(${currentRow + 1})`);
                if (currentRowEl) {
                    currentRowEl.classList.add('invalid-shake');
                    setTimeout(() => currentRowEl.classList.remove('invalid-shake'), 500);
                }
            });
            document.getElementById('debugClearInputRowBtn').addEventListener('click', () => {
                 handleClearAllCurrentRow();
            });


            document.getElementById('debugRunStressTestBtn').addEventListener('click', async () => {
                const runs = parseInt(document.getElementById('debugStressTestRuns').value) || 100;
                const resultsArea = document.getElementById('debugStressTestResults');
                resultsArea.value = `开始 ${runs} 次压力测试...\n`;
                let successes = 0;
                let totalLength = 0;
                const startTime = performance.now();

                const originalDebugSettings = JSON.parse(JSON.stringify(debugSettings));
                const tempLockedLength = debugSettings.lockedLength; 
                const tempDisableMax = debugSettings.disableMaxLength;
                const tempMaxGen = debugSettings.maxGenAttempts;

                for (let i = 0; i < runs; i++) {
                    try {
                        debugSettings.lockedLength = tempLockedLength;
                        debugSettings.disableMaxLength = tempDisableMax;
                        debugSettings.maxGenAttempts = tempMaxGen;

                        const eq = generateRandomEquation();
                        if (eq && eq !== generateFallbackEquation()) { 
                             if (debugSettings.lockedLength > 0 && eq.length !== debugSettings.lockedLength){
                             } else if (!debugSettings.lockedLength && (eq.length < MIN_EQUATION_LENGTH || (!debugSettings.disableMaxLength && eq.length > DEFAULT_MAX_EQUATION_LENGTH) )) {
                             } else {
                                successes++;
                                totalLength += eq.length;
                             }
                        }
                         if (i % Math.floor(runs/10) === 0 || i === runs - 1) {
                             resultsArea.value += `完成 ${i+1}/${runs}...\n`;
                             await new Promise(resolve => setTimeout(resolve, 0)); 
                         }
                    } catch (e) { }
                }
                
                debugSettings.lockedLength = originalDebugSettings.lockedLength;
                debugSettings.disableMaxLength = originalDebugSettings.disableMaxLength;
                debugSettings.maxGenAttempts = originalDebugSettings.maxGenAttempts;

                const endTime = performance.now();
                const duration = (endTime - startTime) / 1000;
                const successRate = (successes / runs) * 100;
                const avgLength = successes > 0 ? (totalLength / successes) : 0;

                resultsArea.value += `测试完成!\n成功率: ${successRate.toFixed(2)}% (${successes}/${runs})\n平均长度: ${avgLength.toFixed(2)}\n用时: ${duration.toFixed(3)}s`;
            });

            document.getElementById('debugNukeStorageBtn').addEventListener('click', () => {
                const nukeModal = document.getElementById('confirmNukeModal');
                const nukeTitle = document.getElementById('confirmNukeTitle');
                const nukeMsg = document.getElementById('confirmNukeMessage');
                const nukeBtn = document.getElementById('executeNukeBtn');

                if (quarkModeActive) {
                    nukeTitle.textContent = "确认清除数据";
                    nukeTitle.style.color = "var(--color-hard)";
                    nukeMsg.textContent = "确定要清除所有本地存储数据吗？包括统计、历史、设置等。此操作将重置游戏到初始状态且无法撤销。";
                    nukeMsg.style.fontWeight = "normal";
                    nukeBtn.textContent = "确认清除本地数据";
                    nukeBtn.style.backgroundColor = "var(--color-hard)";
                    nukeBtn.style.borderColor = "var(--color-hard)";
                } else {
                    nukeTitle.innerHTML = "清除所有数据";
                     nukeTitle.style.color = "var(--color-hard)";
                    nukeMsg.innerHTML = "确定要清除所有本地存储数据吗？包括统计、历史、设置等。此操作将重置游戏到初始状态且无法撤销！";
                    nukeMsg.style.fontWeight = "bold";
                    nukeBtn.innerHTML = "确认清除本地数据";
                    nukeBtn.style.backgroundColor = "#FF0000";
                    nukeBtn.style.borderColor = "#B20000";
                }
                 showModal('confirmNukeModal');
            });
            document.getElementById('executeNukeBtn').addEventListener('click', () => {
                localStorage.clear();
                sessionStorage.clear();
                showMessage("所有本地数据已清除! 正在重载...", 2000);
                setTimeout(() => location.reload(), 2100);
            });
            document.getElementById('cancelNukeBtn').addEventListener('click', () => hideModal('confirmNukeModal'));
            
    window.addEventListener('beforeunload', (event) => {
        if (gameActive && targetEquation && (currentCol > 0 || (COLS > 0 && currentRow > 0) || (isCustomLevel && gameStartTime === 0))) {
            
            const confirmationMessage = '您有未完成的游戏进度，确定要放弃吗？';
            //showMessage(confirmationMessage,2000);
            event.preventDefault();
            event.returnValue = confirmationMessage;
            recordGameInHistory(false, ABANDONED_STATUS);
            return confirmationMessage;
        }
    });


            setupTitleSpans(ORIGINAL_TITLE_TEXT);
            titleFallAnimation.originalComputedTop = getComputedStyle(headerTitleElement).top;
            titleFallAnimation.originalComputedTransition = getComputedStyle(headerTitleElement).transition;
            headerTitleElement.style.transform = 'translateX(-50%)';

            updateStatsDisplay();
            resetGame();
            applyTheme(currentTheme);
            if ('serviceWorker'in navigator) {
                const swScript = `const CACHE_NAME='sumzle-cache-v1.15';const urlsToCache=['./Sumzle.html','https://cdn.staticfile.net/Chart.js/3.9.1/chart.js','https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js','sounds/keypress.wav','sounds/success.wav','sounds/failure.wav'];self.addEventListener('install',event=>{event.waitUntil(caches.open(CACHE_NAME).then(cache=>{const cachePromises=urlsToCache.map(urlToCache=>{let request=urlToCache;if(urlToCache.startsWith('https://cdn.')){request=new Request(urlToCache,{mode:'cors'})}return cache.add(request).catch(err=>{})});let mainPageUrl=self.location.origin+self.location.pathname;if(self.location.pathname.endsWith('Sumzle.html')){mainPageUrl=self.location.href}else if(self.location.pathname==='/'||self.location.pathname===''){mainPageUrl=self.location.origin+'/Sumzle.html'}if(!urlsToCache.includes(mainPageUrl)&&!urlsToCache.includes('.'+self.location.pathname)&&!urlsToCache.includes(self.location.pathname.substring(1))){cachePromises.push(cache.add(mainPageUrl).catch(err=>{}))}return Promise.all(cachePromises)})),self.skipWaiting()});self.addEventListener('activate',event=>{event.waitUntil(caches.keys().then(cacheNames=>{return Promise.all(cacheNames.filter(cacheName=>cacheName!==CACHE_NAME).map(cacheName=>caches.delete(cacheName)))})),self.clients.claim()});self.addEventListener('fetch',event=>{event.respondWith(caches.match(event.request).then(response=>{if(response){return response}return fetch(event.request).then(networkResponse=>{if(!networkResponse||networkResponse.status!==200){return networkResponse}const requestUrl=new URL(event.request.url);const isCachable=urlsToCache.some(cachedUrl=>{if(cachedUrl.startsWith('.'))return requestUrl.pathname.endsWith(cachedUrl.substring(1));return event.request.url===cachedUrl||requestUrl.pathname.endsWith('Sumzle.html')||requestUrl.pathname.includes('sounds/')})||(requestUrl.pathname===new URL(self.registration.scope).pathname&&event.request.mode==='navigate');if(isCachable&&(networkResponse.type==='basic'||networkResponse.type==='cors')){const responseToCache=networkResponse.clone();caches.open(CACHE_NAME).then(cache=>{cache.put(event.request,responseToCache)})}return networkResponse}).catch(error=>{if(event.request.mode==='navigate'){let mainPageFallback='./Sumzle.html';if(self.location.pathname.endsWith('Sumzle.html')){mainPageFallback=self.location.href}else if(new URL(self.registration.scope).pathname==='/'&&(self.location.pathname==='/'||self.location.pathname==='')){mainPageFallback=new URL('/Sumzle.html',self.location.origin).href}return caches.match(mainPageFallback).then(res=>{return res||caches.match('./Sumzle.html')})}})})});`;
                try {
                    const blob = new Blob([swScript.trim()],{
                        type: 'application/javascript'
                    });
                    const swURL = URL.createObjectURL(blob);
                    navigator.serviceWorker.register(swURL, {
                        scope: './'
                    }).then(registration=>{}
                    ).catch(error=>{}
                    );
                } catch (e) {}
            }
        }
        );
    </script>
</body>
</html>